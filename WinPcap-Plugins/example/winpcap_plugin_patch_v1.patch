diff -urN winpcap/create_include.bat winpcap_plugin/create_include.bat
--- winpcap/create_include.bat	2007-11-13 09:48:52.000000000 -0800
+++ winpcap_plugin/create_include.bat	2011-02-19 19:14:23.171875000 -0800
@@ -5,42 +5,43 @@
 IF ""=="%1" (set WINPCAPSOURCEDIR=.\) ELSE (set WINPCAPSOURCEDIR=%1) 
 
 echo Creating \Include folder
-mkdir %WPDPACKDESTDIR%  		2>nul >nul
-mkdir %WPDPACKDESTDIR%\Include  	2>nul >nul
-mkdir %WPDPACKDESTDIR%\Include\pcap  	2>nul >nul
+mkdir %WPDPACKDESTDIR%				2>nul >nul
+mkdir %WPDPACKDESTDIR%\Include		2>nul >nul
+mkdir %WPDPACKDESTDIR%\Include\pcap	2>nul >nul
 
 
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap\*.h		 		%WPDPACKDESTDIR%\Include\pcap\	>nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap\*.h	%WPDPACKDESTDIR%\Include\pcap\ >nul
 
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap.h			 	%WPDPACKDESTDIR%\Include\	>nul
-rem xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-int.h			%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-bpf.h		 		%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-namedb.h	 		%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\remote-ext.h		 	%WPDPACKDESTDIR%\Include\	>nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap.h			%WPDPACKDESTDIR%\Include\ >nul
+rem xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-int.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-bpf.h		%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-namedb.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\remote-ext.h	%WPDPACKDESTDIR%\Include\ >nul
 
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-stdinc.h		 	%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\Win32-Extensions\Win32-Extensions.h 	%WPDPACKDESTDIR%\Include\	>nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\pcap-stdinc.h							%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\Win32-Extensions\Win32-Extensions.h			%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\plugin_framework\inc\pcap-plugin-interface.h	%WPDPACKDESTDIR%\Include\ >nul
 
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\Win32\Include\bittypes.h 		%WPDPACKDESTDIR%\Include\	>nul	 
-xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\Win32\Include\ip6_misc.h		%WPDPACKDESTDIR%\Include\	>nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\Win32\Include\bittypes.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\Win32\Include\ip6_misc.h	%WPDPACKDESTDIR%\Include\ >nul
 
-rem xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\Win32\Include\Gnuc.h 		%WPDPACKDESTDIR%\Include\	>nul
+rem xcopy /v /Y %WINPCAPSOURCEDIR%\wpcap\libpcap\Win32\Include\Gnuc.h	%WPDPACKDESTDIR%\Include\ >nul
 
 
 IF "%HAVE_BUGGY_TME_SUPPORT%"=="" ( goto skip_tme )
 
 rem TME stuff
-xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\bucket_lookup.h	 		%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\count_packets.h	 		%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\memory_t.h		 	%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\normal_lookup.h	 		%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\tcp_session.h		 	%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\time_calls.h		 	%WPDPACKDESTDIR%\Include\	>nul
-xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\tme.h			 	%WPDPACKDESTDIR%\Include\	>nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\bucket_lookup.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\count_packets.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\memory_t.h		%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\normal_lookup.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\tcp_session.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\time_calls.h	%WPDPACKDESTDIR%\Include\ >nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\packetNtx\driver\tme.h			%WPDPACKDESTDIR%\Include\ >nul
 
 :skip_tme
 
-xcopy /v /Y %WINPCAPSOURCEDIR%\Common\Packet32.h			 	%WPDPACKDESTDIR%\Include\	>nul
+xcopy /v /Y %WINPCAPSOURCEDIR%\Common\Packet32.h	%WPDPACKDESTDIR%\Include\ >nul
 
 echo Folder \Include created successfully
 set WPDPACKDESTDIR=
diff -urN winpcap/dox/main.txt winpcap_plugin/dox/main.txt
--- winpcap/dox/main.txt	2005-07-15 15:31:02.000000000 -0700
+++ winpcap_plugin/dox/main.txt	2011-02-20 15:07:06.640125000 -0800
@@ -21,6 +21,7 @@
 - \ref wpcap
  - \ref wpcap_def
  - \ref wpcapfunc
+ - \ref pcap-plugin-interface.h "Plugin interface functions"
  - \ref language
  - \ref wpcapsamps
  - \ref wpcap_tut
diff -urN winpcap/dox/prj/winpcap_noc.dox winpcap_plugin/dox/prj/winpcap_noc.dox
--- winpcap/dox/prj/winpcap_noc.dox	2010-06-23 10:22:42.000000000 -0700
+++ winpcap_plugin/dox/prj/winpcap_noc.dox	2011-02-18 19:34:51.906250000 -0800
@@ -518,7 +518,8 @@
                          ../../wpcap/libpcap/rpcapd/utils.h \
                          ../../wpcap/libpcap/rpcapd/daemon.h \
                          ../../wpcap/libpcap/rpcapd/rpcapd.h \
-                         ../../wpcap/libpcap/rpcapd/win32-svc.h
+                         ../../wpcap/libpcap/rpcapd/win32-svc.h \
+                         ../../wpcap\plugin_framework\inc\pcap-plugin-interface.h
 
 # This tag can be used to specify the character encoding of the source files that 
 # doxygen parses. Internally doxygen uses the UTF-8 encoding, which is also the default 
@@ -1066,13 +1067,13 @@
 # compilation will be performed. Macro expansion can be done in a controlled 
 # way by setting EXPAND_ONLY_PREDEF to YES.
 
-MACRO_EXPANSION        = NO
+MACRO_EXPANSION        = YES
 
 # If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
 # then the macro expansion is limited to the macros specified with the 
 # PREDEFINED and EXPAND_AS_DEFINED tags.
 
-EXPAND_ONLY_PREDEF     = NO
+EXPAND_ONLY_PREDEF     = YES
 
 # If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
 # in the INCLUDE_PATH (see below) will be search if a #include is found.
@@ -1100,18 +1101,14 @@
 # undefined via #undef or recursively expanded use the := operator 
 # instead of the = operator.
 
-PREDEFINED             = WIN32 \
-                         _DEBUG_TO_FILE \
-                         EXPAND_AS_DEFINED \
-                         EXPAND_AS_DEFINED \
-                         =
+PREDEFINED             = 
 
 # If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
 # this tag can be used to specify a list of macro names that should be expanded. 
 # The macro definition that is found in the sources will be used. 
 # Use the PREDEFINED tag if you want to use a different macro definition.
 
-EXPAND_AS_DEFINED      = 
+EXPAND_AS_DEFINED      = PLUGIN_FUNCTION
 
 # If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
 # doxygen's preprocessor will remove all function-like macros that are alone 
diff -urN winpcap/wpcap/PRJ/wpcap.vcproj winpcap_plugin/wpcap/PRJ/wpcap.vcproj
--- winpcap/wpcap/PRJ/wpcap.vcproj	2010-06-22 17:17:48.000000000 -0700
+++ winpcap_plugin/wpcap/PRJ/wpcap.vcproj	2011-02-18 20:33:33.859375000 -0800
@@ -43,8 +43,8 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="1"
@@ -124,8 +124,8 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="1"
@@ -204,8 +204,8 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				RuntimeLibrary="0"
 				UsePrecompiledHeader="0"
 				WarningLevel="3"
@@ -284,8 +284,8 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\..\..\AirPcap_DevPack\include;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;HAVE_AIRPCAP_API;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				RuntimeLibrary="0"
 				UsePrecompiledHeader="0"
 				WarningLevel="3"
@@ -363,8 +363,8 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="1"
@@ -444,8 +444,8 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;_DEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="1"
@@ -524,8 +524,8 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				RuntimeLibrary="0"
 				UsePrecompiledHeader="0"
 				WarningLevel="3"
@@ -604,8 +604,8 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions"
-				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API"
+				AdditionalIncludeDirectories="..\libpcap;..\libpcap\lbl;..\libpcap\bpf\;..\..\common;..\libpcap\win32\include;..\Win32-Extensions;..\plugin_framework;..\plugin_framework\inc"
+				PreprocessorDefinitions="LIBPCAP_EXPORTS;WIN32;NDEBUG;_WINDOWS;HAVE_ADDRINFO;YY_NEVER_INTERACTIVE;yylval=pcap_lval;HAVE_STRERROR;__STDC__;INET6;SIZEOF_CHAR=1;SIZEOF_SHORT=2;SIZEOF_INT=4;WPCAP;HAVE_SNPRINTF;HAVE_VSNPRINTF;HAVE_REMOTE;_U_=;_CRT_SECURE_NO_WARNINGS;YY_NO_UNISTD_H;HAVE_TC_API;HAVE_PLUGIN_SUPPORT"
 				RuntimeLibrary="0"
 				UsePrecompiledHeader="0"
 				WarningLevel="3"
@@ -720,6 +720,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\plugin_framework\pcap-plugin.c"
+				>
+			</File>
+			<File
 				RelativePath="..\libpcap\pcap-remote.c"
 				>
 			</File>
@@ -802,6 +806,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\plugin_framework\inc\pcap-plugin-interface.h"
+				>
+			</File>
+			<File
+				RelativePath="..\plugin_framework\pcap-plugin.h"
+				>
+			</File>
+			<File
 				RelativePath="..\libpcap\pcap-remote.h"
 				>
 			</File>
diff -urN winpcap/wpcap/Win32-Extensions/Win32-Extensions.c winpcap_plugin/wpcap/Win32-Extensions/Win32-Extensions.c
--- winpcap/wpcap/Win32-Extensions/Win32-Extensions.c	2008-05-20 14:25:00.000000000 -0700
+++ winpcap_plugin/wpcap/Win32-Extensions/Win32-Extensions.c	2011-02-18 20:42:36.984375000 -0800
@@ -33,6 +33,7 @@
 
 
 #include "pcap-int.h"
+#include "pcap-plugin.h"
 #include <packet32.h>
 
 #ifdef HAVE_REMOTE
@@ -47,6 +48,13 @@
 	{
 		return TcGetReceiveWaitHandle(p);
 	}
+#ifdef HAVE_PLUGIN_SUPPORT
+	else
+	if (p->PluginInstanceHandle != NULL)
+	{
+		return PluginGetReadEvent(p);
+	}
+#endif /* HAVE_PLUGIN_SUPPORT */
 	else
 	if (p->adapter==NULL)
 	{
diff -urN winpcap/wpcap/libpcap/pcap-int.h winpcap_plugin/wpcap/libpcap/pcap-int.h
--- winpcap/wpcap/libpcap/pcap-int.h	2010-06-25 10:44:24.000000000 -0700
+++ winpcap_plugin/wpcap/libpcap/pcap-int.h	2011-02-20 15:18:02.999500000 -0800
@@ -276,6 +276,11 @@
 	PCHAR PpiPacket;
 #endif
 
+#ifdef HAVE_PLUGIN_SUPPORT
+	void* PluginInstanceHandle;
+	ULONG PluginIndex;
+#endif /* HAVE_PLUGIN_SUPPORT */
+
 #ifdef HAVE_LIBDLPI
 	dlpi_handle_t dlpi_hd;
 #endif
diff -urN winpcap/wpcap/libpcap/pcap-win32.c winpcap_plugin/wpcap/libpcap/pcap-win32.c
--- winpcap/wpcap/libpcap/pcap-win32.c	2010-06-25 10:44:24.000000000 -0700
+++ winpcap_plugin/wpcap/libpcap/pcap-win32.c	2011-02-18 20:39:00.390625000 -0800
@@ -57,6 +57,7 @@
 #endif	/* HAVE_REMOTE */
 
 #include "pcap-tc.h"
+#include "pcap-plugin.h"
 
 static int pcap_setfilter_win32_npf(pcap_t *, struct bpf_program *);
 static int pcap_setfilter_win32_dag(pcap_t *, struct bpf_program *);
@@ -865,9 +866,15 @@
 	{
 		p->activate_op = TcActivate;
 	}
+#ifdef HAVE_PLUGIN_SUPPORT
+	else if (IsPluginDevice(p) == TRUE)
+	{
+		p->activate_op = PluginActivate;
+	}
+#endif /* HAVE_PLUGIN_SUPPORT */
 	else
 	{
-	p->activate_op = pcap_activate_win32;
+		p->activate_op = pcap_activate_win32;
 	}
 
 	return (p);
@@ -963,5 +970,15 @@
 int
 pcap_platform_finddevs(pcap_if_t **alldevsp, char *errbuf)
 {
+#ifdef HAVE_PLUGIN_SUPPORT
+	int result = 0;
+
+	result = PluginFindAllDevs(alldevsp, errbuf);
+	if (result < 0)
+	{
+		return result;
+	}
+#endif /* HAVE_PLUGIN_SUPPORT */
+
 	return TcFindAllDevs(alldevsp, errbuf);
 }
diff -urN winpcap/wpcap/plugin_framework/example_plugin/example_plugin.c winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.c
--- winpcap/wpcap/plugin_framework/example_plugin/example_plugin.c	1969-12-31 16:00:00.000000000 -0800
+++ winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.c	2011-02-18 20:49:58.546875000 -0800
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2011, Dustin Johnson (Dustin@Dustinj.us)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <windows.h>
+#include <stdio.h>
+#include "Strsafe.h"
+
+typedef struct _PluginInstance PluginInstance;
+#define PLUGIN_INSTANCE_TYPE PluginInstance
+#include "pcap-plugin-interface.h"
+
+#define UNUSED(x) (x);
+
+typedef struct _PluginInstance
+{
+    char                 deviceName[MAX_PATH];
+    PLUGIN_PACKET_HEADER packetHeader;
+    UINT8                packet[1024*10];
+    int                  readTimeoutMs;
+    PLUGIN_STATS         stats;
+} PluginInstance;
+
+
+size_t GetPluginApiVersion()
+{
+    return PLUGIN_API_VERSION;
+}
+
+BOOLEAN GetPluginName(OUT char* name, IN size_t nameSizeInBytes)
+{
+    return (BOOLEAN)SUCCEEDED(StringCchCopy(name, nameSizeInBytes, "Example Plugin"));
+}
+
+BOOLEAN GetDeviceList(OUT PLUGIN_DEVICE_DESCRIPTION** devices, OUT char* errorMsg, IN size_t errorMsgSizeInBytes)
+{
+    size_t i = 0;
+
+    for (i = 1; i <= 2; ++i)
+    {
+        PLUGIN_DEVICE_DESCRIPTION* newDeviceDesc = NULL;
+
+        newDeviceDesc = (PLUGIN_DEVICE_DESCRIPTION*)malloc(sizeof(*newDeviceDesc));
+        if (newDeviceDesc == NULL)
+        {
+            StringCchCopy(errorMsg, errorMsgSizeInBytes, "Failed to allocate memory for the device description");
+            FreeDeviceList(*devices);
+            return FALSE;
+        }
+
+        memset(newDeviceDesc, 0, sizeof(*newDeviceDesc));
+
+        if (sprintf_s(newDeviceDesc->name, sizeof(newDeviceDesc->name), "\\\\ExampleDevice\\#%u", i) == -1)
+        {
+            StringCchCopy(errorMsg, errorMsgSizeInBytes, "Device name exceeded allotted space");
+            FreeDeviceList(*devices);
+            return FALSE;
+        }
+
+        if (sprintf_s(newDeviceDesc->description, sizeof(newDeviceDesc->description), "Example Device #%u", i) == -1)
+        {
+            StringCchCopy(errorMsg, errorMsgSizeInBytes, "Device description exceeded allotted space");
+            FreeDeviceList(*devices);
+            return FALSE;
+        }
+
+        newDeviceDesc->next = *devices;
+        *devices = newDeviceDesc;
+    }
+
+    return TRUE;
+}
+
+VOID FreeDeviceList(IN OUT PLUGIN_DEVICE_DESCRIPTION* devices)
+{
+    while(devices != NULL)
+    {
+        PLUGIN_DEVICE_DESCRIPTION* tmpEntry = devices->next;
+
+        free(devices);
+        devices = tmpEntry;
+    }
+}
+
+BOOLEAN OpenInstance(IN char* deviceName, OUT PLUGIN_INSTANCE_TYPE** instanceHandle, OUT char* errorMsg, IN size_t errorMsgSizeInBytes)
+{
+    PLUGIN_INSTANCE_TYPE* newInstance = NULL;
+
+    newInstance = (PLUGIN_INSTANCE_TYPE*)malloc(sizeof(PLUGIN_INSTANCE_TYPE));
+    if (newInstance == NULL)
+    {
+        StringCchCopy(errorMsg, errorMsgSizeInBytes, "Failed to allocate memory for the instance handle");
+        return FALSE;
+    }
+
+    memset(newInstance, 0, sizeof(PLUGIN_INSTANCE_TYPE));
+
+    if (FAILED(StringCchCopy(newInstance->deviceName, sizeof(newInstance->deviceName), deviceName)))
+    {
+        StringCchCopy(errorMsg, errorMsgSizeInBytes, "Device name exceeded allotted space");
+        free(newInstance);
+        return FALSE;
+    }
+
+    *instanceHandle = newInstance;
+
+    return TRUE;
+}
+
+void CloseInstance(IN PLUGIN_INSTANCE_TYPE* instanceHandle)
+{
+    free(instanceHandle);
+}
+
+int GetLinkType(IN PLUGIN_INSTANCE_TYPE* instanceHandle)
+{
+    UNUSED(instanceHandle);
+
+    return 1; // DLT_EN10MB
+}
+
+BOOLEAN GetSupportedDlts(IN PLUGIN_INSTANCE_TYPE* instanceHandle, IN OUT UINT* dltList, IN size_t dltListSizeInBytes, OUT size_t* dltCount)
+{
+    UNUSED(instanceHandle);
+
+    *dltCount = 2;
+
+    if (dltListSizeInBytes < sizeof(UINT)*(*dltCount))
+    {
+        return FALSE;
+    }
+
+    dltList[0] = 1;   // DLT_EN10MB
+    dltList[1] = 147; // DLT_USER0
+
+    return TRUE;
+}
+
+BOOLEAN GetStats(IN PLUGIN_INSTANCE_TYPE* instanceHandle, OUT PLUGIN_STATS* stats, OUT char* errorMsg, IN size_t errorMsgSizeInBytes)
+{
+    UNUSED(errorMsg);
+    UNUSED(errorMsgSizeInBytes);
+
+    instanceHandle->stats.received++;
+    instanceHandle->stats.dropped++;
+
+    *stats = instanceHandle->stats;
+
+    return TRUE;
+}
+
+BOOLEAN SetReadTimeout(IN PLUGIN_INSTANCE_TYPE* instanceHandle, int timeoutMs, OUT char* errorMsg, size_t errorMsgSizeInBytes)
+{
+    UNUSED(errorMsg);
+    UNUSED(errorMsgSizeInBytes);
+
+    instanceHandle->readTimeoutMs = timeoutMs;
+
+    return TRUE;
+}
+
+BOOLEAN GetNextPacket(IN PLUGIN_INSTANCE_TYPE* instanceHandle, OUT PLUGIN_PACKET_HEADER** packetHeader, OUT void** packet, OUT char* errorMsg, size_t errorMsgSizeInBytes)
+{
+    size_t i = 0;
+    FILETIME currentTime;
+    UINT64 uTime;
+
+    UNUSED(errorMsg);
+    UNUSED(errorMsgSizeInBytes);
+
+    *packetHeader = NULL;
+    *packet = NULL;
+
+    instanceHandle->packetHeader.caplen = 128;
+    instanceHandle->packetHeader.len = 128;
+
+    GetSystemTimeAsFileTime(&currentTime);
+
+    uTime = ((UINT64)(currentTime.dwHighDateTime)) << 32;
+    uTime += currentTime.dwLowDateTime;
+
+    uTime /= 10;
+
+    // We now have the number of micro seconds since January 1, 1601.
+    // We need the number of micro seconds since January 1, 1970.
+    // Subtract the number of micro seconds between the two dates.
+    uTime -= 11644473600000000L;
+
+    instanceHandle->packetHeader.ts.tv_sec  = (UINT32)(uTime / 1000000);
+    instanceHandle->packetHeader.ts.tv_usec = (UINT32)(uTime % 1000000);
+
+    for (i = 0; i < instanceHandle->packetHeader.caplen; ++i)
+    {
+        if (i == 0)
+        {
+            instanceHandle->packet[0]++;
+        }
+        else
+        {
+            instanceHandle->packet[i] = instanceHandle->packet[i - 1] + 1;
+        }
+    }
+
+    Sleep(100);
+    *packetHeader = &instanceHandle->packetHeader;
+    *packet = instanceHandle->packet;
+
+    return TRUE;
+}
+
+BOOLEAN SetBufferSize(IN PLUGIN_INSTANCE_TYPE* instanceHandle, size_t sizeInBytes, OUT char* errorMsg, size_t errorMsgSizeInBytes)
+{
+    UNUSED(instanceHandle);
+    UNUSED(sizeInBytes);
+    UNUSED(errorMsg);
+    UNUSED(errorMsgSizeInBytes);
+
+    return TRUE;
+}
+
+BOOLEAN SetMinToCopy(IN PLUGIN_INSTANCE_TYPE* instanceHandle, size_t sizeInBytes, OUT char* errorMsg, size_t errorMsgSizeInBytes)
+{
+    UNUSED(instanceHandle);
+    UNUSED(sizeInBytes);
+    UNUSED(errorMsg);
+    UNUSED(errorMsgSizeInBytes);
+
+    return TRUE;
+}
diff -urN winpcap/wpcap/plugin_framework/example_plugin/example_plugin.def winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.def
--- winpcap/wpcap/plugin_framework/example_plugin/example_plugin.def	1969-12-31 16:00:00.000000000 -0800
+++ winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.def	2011-02-18 19:35:05.453125000 -0800
@@ -0,0 +1,16 @@
+LIBRARY "winpcap_example_plugin"
+
+EXPORTS
+    GetPluginApiVersion
+    GetPluginName
+    GetDeviceList
+    FreeDeviceList
+    OpenInstance
+    CloseInstance
+    GetLinkType
+    GetSupportedDlts
+    GetStats
+    SetReadTimeout
+    GetNextPacket
+    SetBufferSize
+    SetMinToCopy
\ No newline at end of file
diff -urN winpcap/wpcap/plugin_framework/example_plugin/example_plugin.sln winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.sln
--- winpcap/wpcap/plugin_framework/example_plugin/example_plugin.sln	1969-12-31 16:00:00.000000000 -0800
+++ winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.sln	2011-02-18 19:35:05.453125000 -0800
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "example_plugin", "example_plugin.vcproj", "{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Debug|Win32.ActiveCfg = Debug|Win32
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Debug|Win32.Build.0 = Debug|Win32
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Debug|x64.ActiveCfg = Debug|x64
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Debug|x64.Build.0 = Debug|x64
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Release|Win32.ActiveCfg = Release|Win32
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Release|Win32.Build.0 = Release|Win32
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Release|x64.ActiveCfg = Release|x64
+		{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN winpcap/wpcap/plugin_framework/example_plugin/example_plugin.vcproj winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.vcproj
--- winpcap/wpcap/plugin_framework/example_plugin/example_plugin.vcproj	1969-12-31 16:00:00.000000000 -0800
+++ winpcap_plugin/wpcap/plugin_framework/example_plugin/example_plugin.vcproj	2011-02-18 19:35:05.468750000 -0800
@@ -0,0 +1,350 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="example_plugin"
+	ProjectGUID="{7349890F-E284-41BE-AAE1-DAD6FB76A0C4}"
+	RootNamespace="example_plugin"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			ConfigurationType="2"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\inc"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;EXAMPLE_PLUGIN_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				WarnAsError="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)\winpcap_$(ProjectName).dll"
+				LinkIncremental="2"
+				ModuleDefinitionFile="$(ProjectName).def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			ConfigurationType="2"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..\inc"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;EXAMPLE_PLUGIN_EXPORTS"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				WarnAsError="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)\winpcap_$(ProjectName).dll"
+				LinkIncremental="1"
+				ModuleDefinitionFile="$(ProjectName).def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			ConfigurationType="2"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\inc"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;EXAMPLE_PLUGIN_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				WarnAsError="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)\winpcap_$(ProjectName).dll"
+				LinkIncremental="2"
+				ModuleDefinitionFile="$(ProjectName).def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			IntermediateDirectory="$(SolutionDir)$(ConfigurationName)\$(PlatformName)"
+			ConfigurationType="2"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..\inc"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;EXAMPLE_PLUGIN_EXPORTS"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="4"
+				WarnAsError="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)\winpcap_$(ProjectName).dll"
+				LinkIncremental="1"
+				ModuleDefinitionFile="$(ProjectName).def"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\example_plugin.c"
+			>
+		</File>
+		<File
+			RelativePath=".\example_plugin.def"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN winpcap/wpcap/plugin_framework/inc/pcap-plugin-interface.h winpcap_plugin/wpcap/plugin_framework/inc/pcap-plugin-interface.h
--- winpcap/wpcap/plugin_framework/inc/pcap-plugin-interface.h	1969-12-31 16:00:00.000000000 -0800
+++ winpcap_plugin/wpcap/plugin_framework/inc/pcap-plugin-interface.h	2011-02-18 20:47:44.343750000 -0800
@@ -0,0 +1,431 @@
+/*
+ * Copyright (c) 2011, Dustin Johnson (Dustin@Dustinj.us)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __PCAP_PLUGIN_INTERFACE_H__
+#define __PCAP_PLUGIN_INTERFACE_H__
+
+/** \brief A plugin defined type that defaults to \p void.  Plugins can override this type by defining it before the inclusion of this header file. */
+#ifndef PLUGIN_INSTANCE_TYPE
+#define PLUGIN_INSTANCE_TYPE void
+#endif
+
+/** \brief The API version identifier that is to be used with #GetPluginApiVersion */
+#define PLUGIN_API_VERSION 1
+
+/** \brief Used in conjunction with #GetDeviceList and #FreeDeviceList to list the available devices.
+  *
+  * \param name The machine identifier for the device. This parameter will be passed to #OpenInstance to specify which device to open.
+  * \param description The user-friendly description description string for the device.
+  * \param next A pointer to the next device description in the linked list.  If no such device exists or the end of the list has been reached then this parameter must be NULL.
+  *
+  * \remark This structure is allocated and released by the plugin.
+  *
+  * \see GetDeviceList FreeDeviceList OpenInstance
+  *
+  */
+typedef struct _PLUGIN_DEVICE_DESCRIPTION
+{
+    char name[512];
+    char description[512];
+    struct _PLUGIN_DEVICE_DESCRIPTION* next;
+} PLUGIN_DEVICE_DESCRIPTION;
+
+/** \brief Used in conjunction with #GetStats to retrieve device capture statistics.
+  *
+  * \param received The number of packets received by the interface since it was opened.
+  * \param dropped The number of packets dropped by the interface since it was opened.
+  *
+  * \see GetStats
+  *
+  */
+typedef struct _PLUGIN_STATS
+{
+    UINT received;
+    UINT dropped;
+} PLUGIN_STATS;
+
+/** \brief Used in conjunction with #GetNextPacket to carry the particulars of the delivered packet.
+  *
+  * \param tv_sec The number of seconds that has elapsed since January 1st 1970.
+  * \param tv_usec The number of microseconds that has elapsed since the last full second.
+  * \param caplen The number of the packet's bytes that are present in the packet buffer and are available to be read.
+  * \param len The number of bytes originally available when the packet was read into the device.
+  *
+  * \see GetNextPacket
+  *
+  */
+typedef struct _PLUGIN_PACKET_HEADER
+{
+    struct _PLUGIN_TIMEVAL
+    {
+        UINT32 tv_sec;  /* Seconds */
+        UINT32 tv_usec; /* Microseconds */
+    } ts;
+    UINT32 caplen;      /* Length of portion present */
+    UINT32 len;         /* Length this packet (off wire) */
+} PLUGIN_PACKET_HEADER;
+
+/** \brief Used in conjunction with #SetDirection to specify the direction of traffic to capture.
+  *
+  * \see SetDirection
+  *
+  */
+typedef enum _PLUGIN_DIRECTION
+{
+    PLUGIN_DIRECTION_INOUT = 0,
+    PLUGIN_DIRECTION_IN,
+    PLUGIN_DIRECTION_OUT
+} PLUGIN_DIRECTION;
+
+/** \brief Used in conjunction with #SetMode to specify the capture mode that is to be used.
+  *
+  * \see SetMode
+  *
+  */
+typedef enum _PLUGIN_MODE
+{
+    PLUGIN_MODE_CAPT = 0,
+    PLUGIN_MODE_STAT
+} PLUGIN_MODE;
+
+/** \brief Convenience macro to allow the plugin infrastructure to use the same interface definition as the plugins. */
+#ifdef LIBPCAP_EXPORTS
+#define PLUGIN_FUNCTION(type, name) typedef type (__cdecl *fn##name)
+#else
+#define PLUGIN_FUNCTION(type, name) type name
+#endif
+
+/** \name Required
+  * @{
+  */
+    /**
+     * \brief Returns the plugin API version with which the plugin was compiled.
+     *
+     * \return This function is to always return #PLUGIN_API_VERSION.
+     *
+     * \remark This function serves to allow a simple version scheme that gives the plugin framework some ability to change over time.
+     * \remark The plugin framework will determine if it is compatible with the API version returned.  If the plugin is not compatible it will not be loaded.
+     */
+    PLUGIN_FUNCTION(size_t, GetPluginApiVersion) ();
+
+    /**
+     * \brief Returns the user-friendly name of the plugin.
+     *
+     * \param[out] name Pointer to a buffer in which to place the plugin's user-friendly name.
+     * \param[in] nameSizeInBytes The size in bytes of the buffer referenced by \p name.
+     *
+     * \return TRUE if the request succeeds, FALSE otherwise.
+     *
+     * \remark If this function fails it is to return FALSE. In the event of such a failure, the name parameter may be set to anything as it will be discarded.
+     * \remark If TRUE is returned then the name parameter must point to a null terminated ASCII string that is no longer than the supplied nameSizeInBytes parameter.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, GetPluginName) (OUT char* name, size_t nameSizeInBytes);
+
+    /**
+     * \brief Returns the devices to which the plugin has access.
+     *
+     * \param[out] devices Pointer to a linked list of device descriptions.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes.  If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the request succeeds, FALSE otherwise.
+     *
+     * \remark If this function fails it is to return FALSE and set \p errorMsg accordingly. In the event of such a failure, the devices parameter may be set to anything as it will be discarded.
+     * \remark If TRUE is returned then the devices parameter must point to a linked list of device descriptions. If TRUE is returned, the errorMsg parameter is ignored.
+     *
+     * \see FreeDeviceList OpenInstance
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, GetDeviceList) (OUT PLUGIN_DEVICE_DESCRIPTION** devices, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Releases a device list retrieved from #GetDeviceList.
+     *
+     * \param[in,out] devices The device list to be released.
+     *
+     * \remark This function cannot fail.  After calling this function, memory pointed to by \p devices is no longer accessible.
+     *
+     * \see GetDeviceList
+     *
+     */
+    PLUGIN_FUNCTION(void, FreeDeviceList) (IN OUT PLUGIN_DEVICE_DESCRIPTION* devices);
+
+    /**
+     * \brief Creates an instance of the specified device for use with many other functions.
+     *
+     * \param[in] deviceName The name of the device to open as found in the device list retrieved from #GetDeviceList.
+     * \param[out] instanceHandle A pointer to a plugin-defined instance handle. The plugin will use this handle to store instance-specific information.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \remark If this function fails it is to return FALSE and set \p errorMsg accordingly. In the event of such a failure, the instanceHandle parameter may be set to anything as it will be discarded.
+     * \remark If TRUE is returned then \p instanceHandle must point to a valid plugin-specific instance handle. If TRUE is returned, the errorMsg parameter is ignored.
+     *
+     * \see GetDeviceList CloseInstance
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, OpenInstance) (IN char* deviceName, OUT PLUGIN_INSTANCE_TYPE** instanceHandle, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Releases the device that was retrieved from #OpenInstance.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     *
+     * \remark This function cannot fail. After invocation, \p instanceHandle is no longer valid and should be discarded.
+     * \remark This function must return the system to a state such that repeated calls to open and close a device produces no accumulating effects.
+     *
+     * \see OpenInstance
+     *
+     */
+    PLUGIN_FUNCTION(void, CloseInstance) (IN PLUGIN_INSTANCE_TYPE* instanceHandle);
+
+    /**
+     * \brief Returns the link type of packets retrieved with #GetNextPacket.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     *
+     * \return The link type of packets retrieved with #GetNextPacket as defined in bpf.h.
+     *
+     * \remark This function cannot fail.
+     *
+     * \see GetSupportedDlts GetNextPacket
+     *
+     */
+    PLUGIN_FUNCTION(int, GetLinkType) (IN PLUGIN_INSTANCE_TYPE* instanceHandle);
+/** @} */
+
+/** \name Optional
+  * @{
+  */
+    /**
+     * \brief Returns a list of Data Link Types that the device supports.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in,out] dltList A pointer to an array that will hold the DLT list.  This array must be at least \p dltListSizeInBytes bytes long.
+     * \param[in] dltListSizeInBytes The size in bytes of the memory pointed to by \p dltList.
+     * \param[out] dltCount The number of DLTs that were stored in \p dltList.
+     *
+     * \return FALSE if \p dltListSizeInBytes is not large enough to populate all supported DLTs into \p dltList.  TRUE in all other cases.
+     *
+     * \remark This function may only be implemented if #SetDatalink is also implemented.
+     * \remark This may by called multiple times with a larger \p dltListSizeInBytes each succeeding time until success is reported.
+     *
+     * \see SetDatalink
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, GetSupportedDlts) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, IN OUT UINT* dltList, size_t dltListSizeInBytes, OUT size_t* dltCount);
+
+    /**
+     * \brief Returns packet reception statistics.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[out] stats A pointer to a structure that is to be populated with device statistics.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if \p stats has been set to the current statistics for the device. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, GetStats) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, OUT PLUGIN_STATS* stats, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets the Berkeley Packet Filter (BPF) that is to be used to filter packets.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] filter Compiled BPF filter that is to be set in the device.
+     * \param[in] filterSizeInBytes The size in bytes of \p filter.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the BPF filter was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetPacketFilter) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, IN const void* filter, size_t filterSizeInBytes, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets the maximum time to wait for new packets to arrive.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] timeoutMs The maximum number of milliseconds to wait for new packets to arrive before fulfilling a read request.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the read timeout was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetReadTimeout) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, int timeoutMs, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Returns the location of the next packet received by the device and its header.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[out] packetHeader A pointer to the header of the next packet read from the device.
+     * \param[out] packet A pointer to the packet data for the next packet read from the device.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the capture direction was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     * \remark Packet and header data as returned by \p packetHeader and \p packet respectively need only remain valid from one call of #GetNextPacket to the next, allowing for the header and packet data memory to be reused by the plugin.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, GetNextPacket) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, OUT PLUGIN_PACKET_HEADER** packetHeader, OUT void** packet, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Returns the event that gets signaled when the device has at least the minimum bytes to copy available for read.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[out] readEvent A handle to the read event for the device instance.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the read event was returned successfully. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     * \see GetNextPacket SetMinToCopy
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, GetReadEvent) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, OUT HANDLE* readEvent, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Injects a given packet into the device's network medium.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] packet A pointer to the packet data to be sent by the device.
+     * \param[in] packetSizeInBytes The size in bytes of packet pointed to by \p packet.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the capture direction was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, InjectPacket) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, IN const void* packet, size_t packetSizeInBytes, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets a filter indicating from which direction to capture network traffic.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] direction The direction from which to capture network traffic.  All other traffic is to be ignored.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the capture direction was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetDirection) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, PLUGIN_DIRECTION direction, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets the data link to use for delivering network traffic.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] dlt The Data Link Type (DLT) that packets delivered via #GetNextPacket are to have.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the DLT was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     * \see GetSupportedDlts
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetDatalink) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, int dlt, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Retrieves the blocking state of the plugin.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[out] nonBlocking TRUE if the device is operating in non-blocking mode, FALSE otherwise.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the requested non-blocking mode was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     * \see SetNonBlocking
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, IsNonBlocking) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, OUT BOOLEAN* nonBlocking, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets the blocking state of the plugin.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] nonBlocking TRUE if the device is to operate in non-blocking mode, FALSE otherwise.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the requested non-blocking mode was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     * \see IsNonBlocking
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetNonBlocking) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, BOOLEAN nonBlocking, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets the kernel mode buffer size of the plugin.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] sizeInBytes The size in bytes of the kernel mode buffer.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the kernel mode buffered was successfully configured with the requested size. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     * \see SetMinToCopy
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetBufferSize) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, size_t sizeInBytes, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets the capture mode of the plugin.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] mode The capture mode in which the device is to operate.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the capture mode was successfully configured. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetMode) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, PLUGIN_MODE mode, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+
+    /**
+     * \brief Sets the minimum amount of data that must be present in the device before it is made accessible.
+     *
+     * \param[in] instanceHandle The plugin specific handle for the device as returned by #OpenInstance.
+     * \param[in] sizeInBytes The size in bytes that must be present in the device before it is made accessible for a read operation.
+     * \param[out] errorMsg Pointer to a character buffer of length \p errorMsgSizeInBytes. If an error occurs, this buffer must contain a null-terminated and user-friendly error description.
+     * \param[in] errorMsgSizeInBytes The size in bytes of the buffer referenced by \p errorMsg.
+     *
+     * \return TRUE if the minimum to copy was successfully configured with the requested size. FALSE in all other cases.  If FALSE is returned \p errorMsg must contain a null-terminated and user-friendly error description.
+     *
+     * \see SetBufferSize
+     *
+     */
+    PLUGIN_FUNCTION(BOOLEAN, SetMinToCopy) (IN PLUGIN_INSTANCE_TYPE* instanceHandle, size_t sizeInBytes, OUT char* errorMsg, size_t errorMsgSizeInBytes);
+/** @} */
+
+#endif /* __PCAP_PLUGIN_INTERFACE_H__ */
diff -urN winpcap/wpcap/plugin_framework/pcap-plugin.c winpcap_plugin/wpcap/plugin_framework/pcap-plugin.c
--- winpcap/wpcap/plugin_framework/pcap-plugin.c	1969-12-31 16:00:00.000000000 -0800
+++ winpcap_plugin/wpcap/plugin_framework/pcap-plugin.c	2011-02-18 20:47:13.953125000 -0800
@@ -0,0 +1,780 @@
+/*
+ * Copyright (c) 2011, Dustin Johnson (Dustin@Dustinj.us)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef HAVE_PLUGIN_SUPPORT
+
+#include <pcap.h>
+#include <pcap-int.h>
+
+#include <malloc.h>
+#include <memory.h>
+#include <string.h>
+#include <errno.h>
+
+#include "strsafe.h"
+#include "pcap-plugin.h"
+#include "pcap-plugin-interface.h"
+
+
+typedef struct _PLUGIN_INSTANCE
+{
+    char    PluginName[MAX_PATH];
+    char    PluginModuleName[MAX_PATH];
+    HMODULE Handle;
+
+    fnGetPluginApiVersion GetPluginApiVersion;
+    fnGetPluginName       GetPluginName;
+
+    fnGetDeviceList  GetDeviceList;
+    fnFreeDeviceList FreeDeviceList;
+
+    fnOpenInstance  OpenInstance;
+    fnCloseInstance CloseInstance;
+
+    fnGetLinkType      GetLinkType;
+    fnGetSupportedDlts GetSupportedDlts;
+
+    fnGetStats        GetStats;
+    fnSetPacketFilter SetPacketFilter;
+    fnSetReadTimeout  SetReadTimeout;
+    fnGetNextPacket   GetNextPacket;
+    fnGetReadEvent    GetReadEvent;
+    fnInjectPacket    InjectPacket;
+    fnSetDirection    SetDirection;
+    fnSetDatalink     SetDatalink;
+    fnIsNonBlocking   IsNonBlocking;
+    fnSetNonBlocking  SetNonBlocking;
+    fnSetBufferSize   SetBufferSize;
+    fnSetMode         SetMode;
+    fnSetMinToCopy    SetMinToCopy;
+} PLUGIN_INSTANCE;
+
+#define PLUGIN_MAX_COUNT 10
+PLUGIN_INSTANCE g_Plugins[PLUGIN_MAX_COUNT];
+UINT32 g_PluginCount = 0;
+
+static void PluginLoadPlugins();
+static void PluginLoadSinglePlugin(char* pluginModuleName);
+
+static int  PluginRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user);
+static int  PluginInject(pcap_t *p, const void *buf, size_t size);
+static int  PluginSetPacketFilter(pcap_t *p, struct bpf_program *fp);
+static int  PluginSetDirection(pcap_t *p, pcap_direction_t dir);
+static int  PluginSetDatalink(pcap_t *p, int dlt);
+static int  PluginGetNonBlock(pcap_t *p, char *errbuf);
+static int  PluginSetNonBlock(pcap_t *p, int nonblock, char *errbuf);
+static int  PluginGetStats(pcap_t *p, struct pcap_stat *ps);
+static int  PluginSetBuff(pcap_t *p, int dim);
+static int  PluginSetMode(pcap_t *p, int mode);
+static int  PluginSetMinToCopy(pcap_t *p, int size);
+static void PluginCleanup(pcap_t *p);
+
+static pcap_if_t* pluginCreateInterface(PLUGIN_DEVICE_DESCRIPTION device);
+static BOOLEAN pluginFindPluginForDevice(pcap_t *p, size_t* pluginIndex);
+
+static void PluginLoadPlugins()
+{
+    HANDLE fileHandle;
+    WIN32_FIND_DATA findFileData;
+    char pluginSearchPath[MAX_PATH];
+
+    // Get the location of the system directory and add on
+    // the file pattern that we will use to look for plugins
+    {
+        char systemDirectoryPath[MAX_PATH];
+        UINT returnedLength = 0;
+        char* pluginFilePattern = "winpcap_*.dll";
+
+        returnedLength = GetSystemDirectory(systemDirectoryPath, _countof(systemDirectoryPath));
+        if (returnedLength == 0)
+        {
+            // Some error occurred while retrieving the system path
+            return;
+        }
+
+        returnedLength = sprintf_s(pluginSearchPath, sizeof(pluginSearchPath), "%s\\%s", systemDirectoryPath, pluginFilePattern);
+        if (returnedLength == -1)
+        {
+            // Must have exceeded the size of our destination
+            return;
+        }
+    }
+
+    // Find the first file
+    fileHandle = FindFirstFile(pluginSearchPath, &findFileData); 
+    if(fileHandle == INVALID_HANDLE_VALUE)
+    {
+        // Didn't find any plugins or, perhaps, some other error
+        return;
+    }
+
+    do
+    {
+        // Skip directories
+        if(!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
+        {
+            PluginLoadSinglePlugin(findFileData.cFileName);
+        }
+    } while (FindNextFile(fileHandle, &findFileData));
+
+    // Close the file handle
+    FindClose(fileHandle);
+}
+
+static void PluginLoadSinglePlugin(char* pluginModuleName)
+{
+    PLUGIN_INSTANCE* plugin = NULL;
+    static volatile LONG isCurrentlyLoading = FALSE;
+    static LONG localIsCurrentlyLoading = FALSE;
+    size_t index = 0;
+
+    // Can't load more plugins than we have room for
+    if (g_PluginCount >= PLUGIN_MAX_COUNT)
+    {
+        goto Exit;
+    }
+
+    // Make sure that there is only one thread in here at a time, poor man's wait lock
+    while(InterlockedCompareExchange(&isCurrentlyLoading, TRUE, FALSE) == TRUE)
+    {
+        Sleep(1);
+    }
+
+    for (index = 0; index < g_PluginCount; ++index)
+    {
+        if (strcmp(pluginModuleName, g_Plugins[index].PluginModuleName) == 0)
+        {
+            // Already loaded
+            goto Exit;
+        }
+    }
+
+    plugin = &g_Plugins[g_PluginCount];
+    memset(plugin, 0, sizeof(*plugin));
+
+    plugin->Handle = LoadLibrary(pluginModuleName);
+    if (plugin->Handle == NULL)
+    {
+        // Failed to load the plugin module, is it really a DLL?
+        goto Exit;
+    }
+
+    if (FAILED(StringCchCopy(plugin->PluginModuleName, sizeof(plugin->PluginModuleName), pluginModuleName)))
+    {
+        goto Exit;
+    }
+
+    // Core plugin functions
+    plugin->GetPluginApiVersion = (fnGetPluginApiVersion) GetProcAddress(plugin->Handle, "GetPluginApiVersion");
+    plugin->GetPluginName       = (fnGetPluginName)       GetProcAddress(plugin->Handle, "GetPluginName");
+
+    // Required pcap function
+    plugin->GetDeviceList  = (fnGetDeviceList)  GetProcAddress(plugin->Handle, "GetDeviceList");
+    plugin->FreeDeviceList = (fnFreeDeviceList) GetProcAddress(plugin->Handle, "FreeDeviceList");
+    plugin->OpenInstance   = (fnOpenInstance)   GetProcAddress(plugin->Handle, "OpenInstance");
+    plugin->CloseInstance  = (fnCloseInstance)  GetProcAddress(plugin->Handle, "CloseInstance");
+    plugin->GetLinkType    = (fnGetLinkType)    GetProcAddress(plugin->Handle, "GetLinkType");
+
+    // Optional functions
+    plugin->GetSupportedDlts = (fnGetSupportedDlts) GetProcAddress(plugin->Handle, "GetSupportedDlts");
+    plugin->GetStats         = (fnGetStats)         GetProcAddress(plugin->Handle, "GetStats");
+    plugin->SetPacketFilter  = (fnSetPacketFilter)  GetProcAddress(plugin->Handle, "SetPacketFilter");
+    plugin->SetReadTimeout   = (fnSetReadTimeout)   GetProcAddress(plugin->Handle, "SetReadTimeout");
+    plugin->GetNextPacket    = (fnGetNextPacket)    GetProcAddress(plugin->Handle, "GetNextPacket");
+    plugin->GetReadEvent     = (fnGetReadEvent)     GetProcAddress(plugin->Handle, "GetReadEvent");
+    plugin->InjectPacket     = (fnInjectPacket)     GetProcAddress(plugin->Handle, "InjectPacket");
+    plugin->SetDirection     = (fnSetDirection)     GetProcAddress(plugin->Handle, "SetDirection");
+    plugin->SetDatalink      = (fnSetDatalink)      GetProcAddress(plugin->Handle, "SetDatalink");
+    plugin->IsNonBlocking    = (fnIsNonBlocking)    GetProcAddress(plugin->Handle, "IsNonBlocking");
+    plugin->SetNonBlocking   = (fnSetNonBlocking)   GetProcAddress(plugin->Handle, "SetNonBlocking");
+    plugin->SetBufferSize    = (fnSetBufferSize)    GetProcAddress(plugin->Handle, "SetBufferSize");
+    plugin->SetMode          = (fnSetMode)          GetProcAddress(plugin->Handle, "SetMode");
+    plugin->SetMinToCopy     = (fnSetMinToCopy)     GetProcAddress(plugin->Handle, "SetMinToCopy");
+
+    if (plugin->GetPluginApiVersion == NULL ||
+        plugin->GetPluginName       == NULL ||
+        plugin->GetDeviceList       == NULL ||
+        plugin->FreeDeviceList      == NULL ||
+        plugin->OpenInstance        == NULL ||
+        plugin->CloseInstance       == NULL ||
+        plugin->GetLinkType         == NULL)
+    {
+        // These are considered core plugin capabilities and must be supported by all plugins
+        goto Exit;
+    }
+
+    if ((plugin->GetSupportedDlts == NULL) ^ (plugin->SetDatalink == NULL))
+    {
+        // Can't have the ability to retrieve the DLT list but not set the DLT and vice versa.
+        goto Exit;
+    }
+
+    if (plugin->GetPluginApiVersion() != PLUGIN_API_VERSION)
+    {
+        goto Exit;
+    }
+
+    if (!plugin->GetPluginName(plugin->PluginName, sizeof(plugin->PluginName)))
+    {
+        goto Exit;
+    }
+
+    g_PluginCount++;
+
+Exit:
+    isCurrentlyLoading = FALSE;
+}
+
+int PluginFindAllDevs(pcap_if_t **alldevsp, char *errbuf)
+{
+    size_t i = 0;
+
+    PluginLoadPlugins();
+
+    for (i = 0; i < g_PluginCount; ++i)
+    {
+        PLUGIN_DEVICE_DESCRIPTION* pluginDevices = NULL;
+        PLUGIN_DEVICE_DESCRIPTION* currentPluginDevice = NULL;
+        pcap_if_t* outputDevices = NULL;
+
+        if (!g_Plugins[i].GetDeviceList(&pluginDevices, errbuf, (errbuf == NULL) ? 0 : PCAP_ERRBUF_SIZE))
+        {
+            return -1;
+        }
+
+        for (currentPluginDevice = pluginDevices; currentPluginDevice != NULL; currentPluginDevice = currentPluginDevice->next)
+        {
+            pcap_if_t* newDevice = NULL;
+
+            newDevice = pluginCreateInterface(*currentPluginDevice);
+            if (newDevice == NULL)
+            {
+                if (errbuf != NULL)
+                {
+                    StringCchCopy(errbuf, PCAP_ERRBUF_SIZE, "Failed to allocate memory for the device description");
+                }
+                g_Plugins[i].FreeDeviceList(pluginDevices);
+                return -1;
+            }
+
+            newDevice->next = outputDevices;
+            outputDevices = newDevice;
+        }
+
+        g_Plugins[i].FreeDeviceList(pluginDevices);
+
+        while (outputDevices != NULL)
+        {
+            pcap_if_t* tmpDevice = outputDevices->next;
+
+            outputDevices->next = *alldevsp;
+            *alldevsp = outputDevices;
+            outputDevices = tmpDevice;
+        }
+    }
+
+    return 0;
+}
+
+int PluginActivate(pcap_t *p)
+{
+    PLUGIN_INSTANCE* plugin = NULL;
+
+    if (!pluginFindPluginForDevice(p, &p->PluginIndex))
+    {
+        return -1;
+    }
+
+    plugin = &g_Plugins[p->PluginIndex];
+
+    if (!plugin->OpenInstance(p->opt.source, &p->PluginInstanceHandle, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    // We need to guard SetReadTimeout as it is an optional function
+    if (plugin->SetReadTimeout != NULL)
+    {
+        if (!plugin->SetReadTimeout(p->PluginInstanceHandle, p->md.timeout, p->errbuf, PCAP_ERRBUF_SIZE))
+        {
+            return -1;
+        }
+    }
+
+    p->linktype = plugin->GetLinkType(p->PluginInstanceHandle);
+
+    if (plugin->GetSupportedDlts == NULL)
+    {
+        p->dlt_list = (u_int*)malloc(sizeof(u_int));
+        if (p->dlt_list == NULL)
+        {
+            StringCchCopy(p->errbuf, PCAP_ERRBUF_SIZE, "Failed to allocate memory for the device's DLT list");
+            return -1;
+        }
+
+        p->dlt_list[0] = p->linktype;
+        p->dlt_count = 1;
+    }
+    else
+    {
+        size_t dltCount = 0;
+        size_t listSizeInBytes = sizeof(u_int);
+
+        // Get the list of supported DLTs from the plugin.
+        // Start with an array of 2 and double the array size until the array is successfully returned.
+
+        p->dlt_list = NULL;
+
+        do 
+        {
+            if (p->dlt_list != NULL)
+            {
+                free(p->dlt_list);
+            }
+
+            listSizeInBytes *= 2;
+            p->dlt_list = (u_int*)malloc(listSizeInBytes);
+            if (p->dlt_list == NULL)
+            {
+                StringCchCopy(p->errbuf, PCAP_ERRBUF_SIZE, "Failed to allocate memory for the device's DLT list");
+                return -1;
+            }
+        } while (!plugin->GetSupportedDlts(p->PluginInstanceHandle, p->dlt_list, listSizeInBytes, &dltCount));
+
+        p->dlt_count = (int)dltCount;
+    }
+
+    if (plugin->GetNextPacket != NULL)   { p->read_op = PluginRead;                 }
+    if (plugin->InjectPacket != NULL)    { p->inject_op = PluginInject;             }
+    p->setfilter_op = PluginSetPacketFilter;
+    if (plugin->SetDirection != NULL)    { p->setdirection_op = PluginSetDirection; }
+    if (plugin->SetDatalink != NULL)     { p->set_datalink_op = PluginSetDatalink;  }
+    if (plugin->IsNonBlocking != NULL)   { p->getnonblock_op = PluginGetNonBlock;   }
+    if (plugin->SetNonBlocking != NULL)  { p->setnonblock_op = PluginSetNonBlock;   }
+    if (plugin->GetStats != NULL)        { p->stats_op = PluginGetStats;            }
+    if (plugin->SetBufferSize != NULL)   { p->setbuff_op = PluginSetBuff;           }  
+    if (plugin->SetMode != NULL)         { p->setmode_op = PluginSetMode;           }
+    if (plugin->SetMinToCopy != NULL)    { p->setmintocopy_op = PluginSetMinToCopy; }
+    p->cleanup_op = PluginCleanup;
+
+    return 0;
+}
+
+BOOLEAN IsPluginDevice(pcap_t *p)
+{
+    pcap_if_t* allPluginDevices = NULL;
+    BOOLEAN deviceFound = FALSE;
+
+    if (PluginFindAllDevs(&allPluginDevices, NULL) < 0)
+    {
+        return FALSE;
+    }
+
+    {
+        pcap_if_t* currentDevice = allPluginDevices;
+
+        while (currentDevice != NULL)
+        {
+            if (strcmp(currentDevice->name, p->opt.source) == 0)
+            {
+                deviceFound = TRUE;
+                break;
+            }
+
+            currentDevice = currentDevice->next;
+        }
+    }
+
+    pcap_freealldevs(allPluginDevices);
+
+    return deviceFound;
+}
+
+HANDLE PluginGetReadEvent(pcap_t *p)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+    HANDLE readEvent = NULL;
+
+    if(plugin->GetReadEvent == NULL) 
+    {
+        StringCchCopy(p->errbuf, PCAP_ERRBUF_SIZE, "This device does not support the retrieval of a read event");
+        return NULL;
+    }
+
+    if (!plugin->GetReadEvent(p->PluginInstanceHandle, &readEvent, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return NULL;
+    }
+
+    return readEvent;
+}
+
+static int PluginRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+    int packetCount = 0;
+
+    if (p->break_loop)
+    {
+        p->break_loop = 0;
+        return -2;
+    }
+
+    do
+    {
+        PLUGIN_PACKET_HEADER* packetHeader;
+        void* packet;
+
+        if (p->break_loop) 
+        {
+            if (packetCount == 0) 
+            {
+                p->break_loop = 0;
+                return (-2);
+            }
+            else
+            {
+                return packetCount;
+            }
+        }
+
+        if (!plugin->GetNextPacket(p->PluginInstanceHandle, &packetHeader, &packet, p->errbuf, PCAP_ERRBUF_SIZE))
+        {
+            return -1;
+        }
+
+        if (packetHeader != NULL && packet != NULL)
+        {
+            struct pcap_pkthdr pcapHeader;
+
+            pcapHeader.ts.tv_sec  = packetHeader->ts.tv_sec;
+            pcapHeader.ts.tv_usec = packetHeader->ts.tv_usec;
+            pcapHeader.caplen     = packetHeader->caplen;
+            pcapHeader.len        = packetHeader->len;
+
+            // Check to see if this instance needs user mode filtering, if so then do it
+            if (p->md.use_bpf == 0 && p->fcode.bf_insns != NULL) 
+            {
+                u_int filterResult = 0;
+
+                filterResult = bpf_filter(p->fcode.bf_insns, packet, pcapHeader.len, pcapHeader.caplen);
+
+                if (filterResult == 0)
+                {
+                    continue;
+                }
+
+                if (filterResult < pcapHeader.caplen)
+                {
+                    pcapHeader.caplen = filterResult;
+                }
+            }
+
+            (*callback)(user, &pcapHeader, packet);
+            packetCount++;
+        }
+    } while (packetCount < cnt || cnt == -1);
+
+    return packetCount;
+}
+
+static int PluginInject(pcap_t *p, const void *buf, size_t size)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+
+    if (!plugin->InjectPacket(p->PluginInstanceHandle, buf, size, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int PluginSetPacketFilter(pcap_t *p, struct bpf_program *fp)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+
+    if(fp == NULL) 
+    {
+        StringCchCopy(p->errbuf, PCAP_ERRBUF_SIZE, "No filter specified");
+        return -1;
+    }
+
+    // If the plugin provides the ability to set kernel filtering then use that.
+    // Otherwise, install the filter as a user mode filter and the plugin framework
+    // will handle the packet filtering.
+    if (plugin->SetPacketFilter != NULL)
+    {
+        if (!plugin->SetPacketFilter(p->PluginInstanceHandle, fp->bf_insns, fp->bf_len * sizeof(*fp->bf_insns), p->errbuf, PCAP_ERRBUF_SIZE))
+        {
+            return -1;
+        }
+    }
+    else
+    {
+        // Install a user level filter
+        if (install_bpf_program(p, fp) < 0)
+        {
+            sprintf_s(p->errbuf, sizeof(p->errbuf), "Unable to install the filter: %s", pcap_strerror(errno));
+            return -1;
+        }
+
+        // Indicate that BPF filtering is to happen outside of the kernel
+        p->md.use_bpf = 0;
+    }
+
+    return 0;
+}
+
+static int PluginSetDirection(pcap_t *p, pcap_direction_t dir)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+    PLUGIN_DIRECTION localDir;
+
+    switch (dir)
+    {
+        case PCAP_D_INOUT: localDir = PLUGIN_DIRECTION_INOUT; break;
+        case PCAP_D_IN:    localDir = PLUGIN_DIRECTION_IN;    break;
+        case PCAP_D_OUT:   localDir = PLUGIN_DIRECTION_OUT;   break;
+        default:
+            StringCchCopy(p->errbuf, PCAP_ERRBUF_SIZE, "Unknown pcap direction encountered");
+            return -1;
+    }
+
+    if (!plugin->SetDirection(p->PluginInstanceHandle, localDir, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int PluginSetDatalink(pcap_t *p, int dlt)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+
+    if (!plugin->SetDatalink(p->PluginInstanceHandle, dlt, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int PluginGetNonBlock(pcap_t *p, char *errbuf)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+    BOOLEAN blocking;
+
+    if (!plugin->IsNonBlocking(p->PluginInstanceHandle, &blocking, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        if (errbuf != NULL)
+        {
+            StringCchCopy(errbuf, PCAP_ERRBUF_SIZE, p->errbuf);
+        }
+        return -1;
+    }
+
+    return blocking;
+}
+
+static int PluginSetNonBlock(pcap_t *p, int nonblock, char *errbuf)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+
+    if (!plugin->SetNonBlocking(p->PluginInstanceHandle, (BOOLEAN)(nonblock == TRUE), p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        if (errbuf != NULL)
+        {
+            StringCchCopy(errbuf, PCAP_ERRBUF_SIZE, p->errbuf);
+        }
+        return -1;
+    }
+
+    return 0;
+}
+
+static int PluginGetStats(pcap_t *p, struct pcap_stat *ps)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+    PLUGIN_STATS localStats;
+
+    memset(&localStats, 0, sizeof(localStats));
+    memset(ps, 0, sizeof(*ps));
+
+    if (!plugin->GetStats(p->PluginInstanceHandle, &localStats, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    ps->ps_recv = localStats.received;
+    ps->ps_drop = localStats.dropped;
+
+    return 0;
+}
+
+static int PluginSetBuff(pcap_t *p, int dim)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+
+    if (!plugin->SetBufferSize(p->PluginInstanceHandle, dim, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int PluginSetMode(pcap_t *p, int mode)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+    PLUGIN_MODE localMode;
+
+    switch (mode)
+    {
+        case MODE_CAPT: localMode = PLUGIN_MODE_CAPT; break;
+        case MODE_STAT: localMode = PLUGIN_MODE_STAT; break;
+        default:
+            StringCchCopy(p->errbuf, PCAP_ERRBUF_SIZE, "Unknown pcap mode encountered");
+            return -1;
+    }
+
+    if (!plugin->SetDirection(p->PluginInstanceHandle, localMode, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int PluginSetMinToCopy(pcap_t *p, int size)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+
+    if (!plugin->SetMinToCopy(p->PluginInstanceHandle, size, p->errbuf, PCAP_ERRBUF_SIZE))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static void PluginCleanup(pcap_t *p)
+{
+    PLUGIN_INSTANCE* plugin = &g_Plugins[p->PluginIndex];
+
+    if (p->PluginInstanceHandle != NULL)
+    {
+        plugin->CloseInstance(p->PluginInstanceHandle);
+        p->PluginInstanceHandle = NULL;
+    }
+
+    pcap_cleanup_live_common(p);
+}
+
+
+static pcap_if_t* pluginCreateInterface(PLUGIN_DEVICE_DESCRIPTION device)
+{
+    pcap_if_t *newIf = NULL;
+    size_t nameSize = 0;
+    size_t descriptionSize = 0;
+
+    newIf = (pcap_if_t*)malloc(sizeof(*newIf));
+    if (newIf == NULL)
+    {
+        return NULL;
+    }
+
+    memset(newIf, 0, sizeof(*newIf));
+
+    nameSize = strlen(device.name) + 1;
+    newIf->name = (char*)malloc(nameSize);
+    if (newIf->name == NULL)
+    {
+        free(newIf);
+        return NULL;
+    }
+
+    descriptionSize = strlen(device.description) + 1;
+    newIf->description = (char*)malloc(descriptionSize);
+    if (newIf->description == NULL)
+    {
+        free(newIf->name);
+        free(newIf);
+        return NULL;
+    }
+
+    StringCchCopy(newIf->name, nameSize, device.name);
+    StringCchCopy(newIf->description, descriptionSize, device.description);
+
+    newIf->addresses = NULL;
+    newIf->next = NULL;
+    newIf->flags = 0;
+
+    return newIf;
+}
+
+static BOOLEAN pluginFindPluginForDevice(pcap_t *p, size_t* pluginIndex)
+{
+    size_t i = 0;
+
+    *pluginIndex = 0;
+
+    for (i = 0; i < g_PluginCount; ++i)
+    {
+        PLUGIN_DEVICE_DESCRIPTION* pluginDevices = NULL;
+        PLUGIN_DEVICE_DESCRIPTION* currentPluginDevice = NULL;
+
+        if (!g_Plugins[i].GetDeviceList(&pluginDevices, p->errbuf, PCAP_ERRBUF_SIZE))
+        {
+            return FALSE;
+        }
+
+        for (currentPluginDevice = pluginDevices; currentPluginDevice != NULL; currentPluginDevice = currentPluginDevice->next)
+        {
+            if (strcmp(currentPluginDevice->name, p->opt.source) == 0)
+            {
+                *pluginIndex = i;
+                g_Plugins[i].FreeDeviceList(pluginDevices);
+                return TRUE;
+            }
+        }
+
+        g_Plugins[i].FreeDeviceList(pluginDevices);
+    }
+
+    StringCchCopy(p->errbuf, PCAP_ERRBUF_SIZE, "Failed to find a plugin to service the device");
+
+    return FALSE;
+}
+
+#endif // HAVE_PLUGIN_SUPPORT
diff -urN winpcap/wpcap/plugin_framework/pcap-plugin.h winpcap_plugin/wpcap/plugin_framework/pcap-plugin.h
--- winpcap/wpcap/plugin_framework/pcap-plugin.h	1969-12-31 16:00:00.000000000 -0800
+++ winpcap_plugin/wpcap/plugin_framework/pcap-plugin.h	2011-02-18 20:47:22.515625000 -0800
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2011, Dustin Johnson (Dustin@Dustinj.us)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __PCAP_PLUGIN_H__
+#define __PCAP_PLUGIN_H__
+#ifdef HAVE_PLUGIN_SUPPORT
+
+int     PluginFindAllDevs(pcap_if_t **alldevsp, char *errbuf);
+int     PluginActivate(pcap_t *p);
+BOOLEAN IsPluginDevice(pcap_t *p);
+HANDLE  PluginGetReadEvent(pcap_t *p);
+
+#endif // HAVE_PLUGIN_SUPPORT
+#endif // __PCAP_PLUGIN_H__
