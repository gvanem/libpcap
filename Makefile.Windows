#
# libpcap Makefile for MinGW, MSVC or clang-cl (Win32/Win64).
#
# By G. Vanem <gvanem@yahoo.no>  2003 - 2019.
#
VPATH = Win32 missing testprogs testprogs/fuzz

THIS_FILE = Makefile.Windows

define Usage
  Usage: "$(MAKE) -f Makefile.Windows CC=[gcc | cl | clang-cl] <CPU=x86|x64>
         [all | clean | vclean | realclean | depend | install]"
endef

export Usage

ifeq ($(CC),cl)
  MSVC_TYPE  = 1
  lib_select = $(1)
  sys_libs   = $(1)

else ifeq ($(CC),clang-cl)
  MSVC_TYPE  = 1
  lib_select = $(1)
  sys_libs   = $(1)

else
  MSVC_TYPE  = 0
  lib_select = $(2)
  sys_libs   = $(addprefix -l, $(strip $(1:.lib=)))
endif

#
# Options, change to suite:
#
# Set "HAVE_PCAP_REMOTE=1" to enable remote packet-capture.
# Also enables building 'rpcapd/rpcapd.exe'.
#
HAVE_PCAP_REMOTE ?= 1

#
# Enable AirPcap WiFi sniffing.
#
HAVE_AIRPCAP ?= 1

#
# Needed for the 'HAVE_PCAP_REMOTE = 1' and 'rpcapd/rpcapd.exe' only.
#
HAVE_OPENSSL ?= 0

#
# Enable Network Packet Filter Intermediate Driver API
# (old Netmon API?) in WinPcap. Needs <NpfIm.h>.
#
# Hardly possible anymore.
#
HAVE_NPFIM_API ?= 0

#
# Set to 1 to build with WanPacket.cpp. Since it doesn't compile with MinGW,
# we load WanPacket.dll indirectly via Win32/WanPacket_imp.c.
#
HAVE_WANPACKET ?= 1

#
# Enable WinPcap plugin support.
#
HAVE_PLUGINS ?= 1

#
# Build with CACE Tech's TurboCap API.
# MSVC / clang-cl only.
#
HAVE_TC_API ?= 0

#
# Build with CACE Tech's DAG API. Untested since I don't have it.
#
HAVE_DAG_API ?= 0

#
# Set to 1 to create and install man-pages.
#
MAKE_MAN_PAGES ?= 1

#
# MinGW: no effect.
# MSVC:  0: Use the Universal CRT (-MD or -MDd).
#        1: Use the static CRT    (-MT or -MTd).
#
USE_CRT_STATIC ?= 0

#
# MSVC:  debug-model (-MDd / -MTd)  or release (-MD / -MT).
# MinGW: debug-model (-O0 -g) or release (-O2 -fomit-frame-pointer).
#
USE_CRT_DEBUG ?= 0

#
# Build using NPcap instead of WinPcap's Packet32.c etc.
#
USE_NPCAP ?= 0

#
# Build using Win10Pcap instead of WinPcap's Packet32.c etc.
#
USE_WIN10PCAP ?= 0

#
# Use Decnet's getnodebyname.c in nametoaddr.c to support lookup of Decnet
# addresses in gencode.c. Little value today?
#
USE_DECNET ?= 0

#
# Use the tracing Wsock_trace lib (and not ws2_32.lib).
# Currently works best for MSVC/clang-cl.
#   Ref: https://github.com/gvanem/wsock-trace/
#
USE_WSOCK_TRACE ?= 1

#
# Include trace in Packet32.c.
#
USE_PACKET32_DEBUG ?= 0

#
# Use "Visual Leak Detector" for all programs:
#   https://kinddragon.github.io/vld/
#   https://github.com/KindDragon/vld/
#
USE_VLD  ?= 0
VLD_ROOT ?= f:/ProgramFiler/VisualLeakDetector

#
# Include 'PCAP_TRACE()' code in wpcap + rpcapd + plugins.
# Also defines 'BDEBUG' and 'YYDEBUG'.
# See below.
#
PCAP_DEBUG ?= 2

#
# Options for the C/C++ preprocessing macros.
#
USE_GNU_INDENT   ?= 0
USE_CLANG_FORMAT ?= 1

#
# Compile all wpcap.dll sources in one go.
# For MSVC only.
#
USE_MP_COMPILE ?= 1

ifneq ($(CC),cl)
  USE_MP_COMPILE = 0
endif

ifeq ($(USE_NPCAP),1)
  USE_MP_COMPILE = 0
endif

ifneq ($(MSVC_TYPE),1)
  USE_VLD = 0
endif

#
# Enable WinPcap-plugins:
# Build 'WinPcap-Plugins/BlueTooth' -> WinPcap-Plugins/winpcap_btooth_plugin$(X64_SUFFIX).dll
#       'WinPcap-Plugins/USB-pcap'  -> WinPcap-Plugins/winpcap_usb_plugin$(X64_SUFFIX).dll
#       'WinPcap-Plugins/Firewall'  -> WinPcap-Plugins/winpcap_firewall_plugin$(X64_SUFFIX).dll (todo)
#
ifeq ($(HAVE_PLUGINS),1)
  HAVE_BLUETOOTH  = 1
  HAVE_FW_MONITOR = 1
  HAVE_USB_PCAP   = 1
endif

#
# Python is only needed in the below '%.i' rule.
#
PYTHON ?= python

#
# WinPcap base path.
#
WINPCAP_ROOT ?= ./WinPcap

#
# NPcap base path (very experimental).
# Ref:
#   https://github.com/nmap/npcap.git
#
NPCAP_ROOT ?= ./NPcap

#
# Win10Pcap base path.
#
WIN10PCAP_ROOT ?= ./Win10Pcap

#
# AirPcap base path.
#
AIRPCAP_ROOT ?= ./AirPcap

#
# Netmap's libpcap .c-file base path.
#
NETMAP_ROOT ?= ./libpcap-apps/netmap

#
# TurboCap base path.
#
TC_API_ROOT ?= 'c:/Program Files (x86)/Riverbed/TurboCap'

#
# DAG API base path.
#
DAG_API_ROOT ?= "c:/Program Files (x86)/Riverbed/DagApi"

#
# Network Monitor SDK path.
#
NETMON_ROOT ?= f:/ProgramFiler/Microsoft-Network-Monitor-3/API

#
# OpenSSL base path.
#
OPENSSL_ROOT ?= $(MINGW_ROOT)/src/inet/Crypto/OpenSSL

#
# USBPcap base path.
# Ref:
#  https://github.com/desowin/usbpcap
#
USBPCAP_ROOT ?= $(MINGW_ROOT)/src/USB/USBPcap

#
# Where is netdnet/getnodebyname.c located?
#
DECNET_ROOT = ./missing

#
# Modify above 'HAVE_x' to avoid using such features with 'gcc'.
# They won't work.!
#
ifeq ($(CC),gcc)
  ifeq ($(HAVE_TC_API),1)
    $(warning 'HAVE_TC_API=1' is impossible with $(CC).)
    HAVE_TC_API := 0
  endif

  ifeq ($(HAVE_BLUETOOTH),1)
    $(warning 'HAVE_BLUETOOTH=1' is impossible with $(CC).)
    HAVE_BLUETOOTH := 0
  endif
endif

#
# The combination 'HAVE_AIRPCAP=1' with 'USE_NPCAP=1' (or 'USE_WIN10CAP=1'?) is
# *not* supported. This is due to all the 'HAVE_AIRPCAP_API' tests inside the
# $(WINPCAP_ROOT)/PacketNtx/Dll/Packet32.c file. To support AirPcap, all the
# code inside 'HAVE_AIRPCAP_API' will have to be lifted out into a safe place.
# A plugin perhaps?
#
ifeq ($(HAVE_AIRPCAP),1)
  ifeq ($(USE_WIN10PCAP),1)
    #
    # Should work with Win10Pcap (?).
    #
    # $(error Need to set 'HAVE_AIRPCAP=0')

  else ifeq ($(USE_NPCAP),1)
    $(error Need to set 'HAVE_AIRPCAP=0')
  endif
endif

ifeq ($(USE_NPCAP),1)
  ifeq ($(HAVE_WANPACKET),1)
    $(warning 'HAVE_WANPACKET=1' is impossible with NPcap.)
    HAVE_WANPACKET := 0
  endif
endif

#
# The following codes used in macro 'colour_msg' assumes you have
# MSys/Cygwin's echo with colour support.
#
BRIGHT_GREEN = \e[1;32m
BRIGHT_WHITE = \e[1;37m

colour_msg = @echo -e "$(1)\e[0m"
green_msg  = $(call colour_msg,$(BRIGHT_GREEN)$(strip $(1)))
green_msg0 = $(call colour_msg,$(BRIGHT_GREEN)$(1))

VERSION = $(shell cat ./VERSION)
TODAY   = $(shell date +%d-%B-%Y)

MINGW_ROOT  = $(realpath $(MINGW32))
VC_ROOT     = $(realpath $(VCToolkitInstallDir))

cpp_to_obj = $(addprefix $(OBJ_DIR)/, \
               $(notdir $(1:.cpp=.$(O))))

c_to_obj = $(addprefix $(OBJ_DIR)/, \
             $(notdir $(1:.c=.$(O))))

#
# Used when "force including" the Win32/config.h file on every compile.
#
ifeq ($(CC),gcc)
  FORCE_INC = --include Win32/config.h
else
  FORCE_INC = -FI./Win32/config.h
endif

#
# If '$(CPU)=x64', build only 64-bit .dll, libraries and programs.
# Otherwise 32-bit programs.
#
ifeq ($(CPU),)
  #
  # Default CPU is 'x86'.
  #
  CPU := x86
  #
  # Only 32-bit supported with clang-cl.
  #
else ifeq ($(CC),clang-cl)
  CPU := x86
endif

#
# GNU Make handles environment variables in a case-sensitive manner.
#
ifeq ($(CPU),X64)
  BITS = 64
else ifeq ($(CPU),x64)
  BITS = 64
else ifeq ($(CPU),x86)
  BITS = 32
else ifeq ($(CPU),X86)
  BITS = 32
else
  $(error Unsupported $$(CPU)=$(CPU))
endif

ifeq ($(BITS),64)
  LIB_SUBDIR = x64/
  X64_SUFFIX = _64
endif


ifeq ($(CC),cl)
  #
  # Select correct cl.exe and link.exe based on $(CPU) without
  # the 'vcvarsall.bat' non-sense.
  #
  # Note: This assumes you have Visual-Studio 2017 where '%VCToolkitInstallDir%'
  #       defines the base directory for the tools.
  #
  # Note: 'rc.exe' doesn't care about bitness.
  #
  CL_CC   = $(VC_ROOT)/bin/HostX86/$(CPU)/cl.exe
  CFLAGS  = -nologo -Ot -W2
  LDFLAGS = -nologo -map -incremental:no -verbose
  RCFLAGS = -D_MSC_VER
  O       = obj
  OBJ_DIR = MSVC_obj

else ifeq ($(CC),clang-cl)
  #
  # Incase '%CL' is set to e.g. '-MP', undefine it.
  #
  export CL=

  CFLAGS = -nologo -Zi -Zo -Ot -fms-compatibility

  CFLAGS += -GS- -ferror-limit=5 -Wall             \
            -Wno-reserved-id-macro                 \
            -Wno-nonportable-system-include-path   \
            -Wno-sign-conversion                   \
            -Wno-format-nonliteral                 \
            -Wno-unused-value                      \
            -Wno-unused-variable                   \
            -Wno-unused-macros                     \
            -Wno-unused-parameter                  \
            -Wno-unused-function                   \
            -Wno-gnu-zero-variadic-macro-arguments \
            -Wno-conditional-uninitialized         \
            -Wno-unreachable-code                  \
            -Wno-unreachable-code-break            \
            -Wno-strict-prototypes                 \
            -Wno-documentation                     \
            -Wno-conversion                        \
            -Wno-cast-align                        \
            -Wno-language-extension-token          \
            -Wno-unreachable-code-return           \
            -Wno-format-non-iso                    \
            -Wno-missing-prototypes                \
            -Wno-cast-qual                         \
            -Wno-nonportable-include-path          \
            -Wno-\#pragma-messages                 \
            -Wno-covered-switch-default            \
            -Wno-missing-variable-declarations     \
            -Wno-used-but-marked-unused            \
            -Wno-switch-enum                       \
            -Wno-extra-semi-stmt                   \
          # -Wno-missing-noreturn

  #
  # Turn off warnings like:
  #   ./AirPcap/include\airpcap.h(208,18):
  #     warning: zero size arrays are an extension [-Wzero-length-array]
  #        AirpcapKey Keys[0];      //< Array of nKeys keys.
  #
  ifeq ($(HAVE_AIRPCAP),1)
    CFLAGS += -Wno-zero-length-array
  endif

  ifeq ($(USE_NPCAP),1)
    CFLAGS += -Wno-static-in-inline              \
              -Wno-ignored-attributes            \
              -Wno-missing-field-initializers    \
              -Wno-zero-as-null-pointer-constant \
              -Wno-c++98-compat-pedantic         \
              -Wno-old-style-cast                \
              -Wno-undef
  endif

  #
  # These warnings are kinda important. Leave them enabled.
  #
  # CFLAGS += -Wno-incompatible-pointer-types \
  #           -Wno-format-security            \
  #           -Wno-pointer-sign

  #
  # 'CPU=x64' using 'clang-cl' is untested.
  #
  LDFLAGS   = -nologo -map -incremental:no -verbose
  RCFLAGS   = -D__clang__
  O         = obj
  OBJ_DIR   = clang_obj

else ifeq ($(CC),gcc)
  CFLAGS    = -m$(BITS)
  LDFLAGS   = -m$(BITS)
  RCFLAGS   = -D__MINGW32__
  O         = o
  OBJ_DIR   = MinGW_obj

  CFLAGS   += -Wno-unused-function \
              -Wno-unused-value    \
              -Wno-strict-aliasing \
              -Wno-unknown-pragmas \
              -Wno-incompatible-pointer-types

  ifeq ($(BITS),64)
    RCFLAGS += --target=pe-x86-64
  else
    RCFLAGS += --target=pe-i386
  endif

else
  $(error $(Usage))
endif

RCFLAGS += -I.

#
# Names of libraries and DLLs we produce:
#
ifeq ($(MSVC_TYPE),1)
  WPCAP_STAT_LIB  = wpcap$(X64_SUFFIX)_static.lib
  WPCAP2_STAT_LIB = wpcap2$(X64_SUFFIX)_static.lib

  WPCAP_IMP_LIB   = wpcap$(X64_SUFFIX).lib
  WPCAP2_IMP_LIB  = wpcap2$(X64_SUFFIX).lib

  WPCAP_DLL       = wpcap$(X64_SUFFIX).dll
  WPCAP2_DLL      = wpcap2$(X64_SUFFIX).dll

else
  WPCAP_STAT_LIB  = libwpcap$(X64_SUFFIX)_static.a
  WPCAP2_STAT_LIB = libwpcap2$(X64_SUFFIX)_static.a

  WPCAP_IMP_LIB   = libwpcap$(X64_SUFFIX).a
  WPCAP2_IMP_LIB  = libwpcap2$(X64_SUFFIX).a

  WPCAP_DLL       = wpcap$(X64_SUFFIX).dll
  WPCAP2_DLL      = wpcap2$(X64_SUFFIX).dll
endif

#
# Use the correct linker and '-LIBPATH':
#
ifeq ($(MSVC_TYPE),1)
  CL_LINK = $(VC_ROOT)/bin/HostX86/$(CPU)/link.exe

  #
  # The paths for the CRT library (msvcrt.lib):
  #
  CL_LIBS = -libpath:$(VC_ROOT)/lib/$(CPU)

  #
  # 'WindowsKits' root is in $(WK_ROOT) and
  # 'WindowsKits' version is in $(WK_VER).
  #
  # Hence the User-Mode libraries for 'x86' is in:
  #   $(WK_ROOT)/Lib/$(WK_VER)/um/x86/
  #
  CL_LIBS += -libpath:$(realpath $(WK_ROOT)/Lib/$(WK_VER)/um/$(CPU))

  #
  # Ditto mess for the UCRT libraries: for 'x86' the UCRT libs are in:
  #   $(WK_ROOT)/Lib/$(WK_VER)/ucrt/x86/
  #
  CL_LIBS += -libpath:$(realpath $(WK_ROOT)/Lib/$(WK_VER)/ucrt/$(CPU))

  ifeq ($(USE_VLD),1)
    CFLAGS += -Zi                          \
              -DUSE_VLD -DVLD_FORCE_ENABLE \
              -I$(VLD_ROOT)/include

    LDFLAGS += -debug
    CL_LIBS += $(VLD_ROOT)/lib/Win$(BITS)/vld.lib
  else
    #
    # This causes a much faster compile and link using MSVC-2019.
    # But breaks the "Visual Leak Detector".
    #
    CFLAGS  += -Z7 -Zo
    LDFLAGS += -debug:fastlink
  endif
endif

###########################################################################################

ifeq ($(USE_WIN10PCAP),1)
  VPATH += $(WIN10PCAP_ROOT)/Packet_dll

else ifeq ($(USE_NPCAP),1)
  VPATH += $(NPCAP_ROOT)/PacketWin7/Dll \
            $(NPCAP_ROOT)/PacketWin7/Helper/NPcapHelperTest

else
  VPATH += $(WINPCAP_ROOT)/PacketNtx/Dll
endif

#
# $(INSTALL_BIN_DIR):  Final location of wpcap2$(X64_SUFFIX).dll + rpcapd$(X64_SUFFIX).exe
# $(INSTALL_MAN3_DIR): Final location of the *.3 man-pages.
#
INSTALL_BIN_DIR  = $(realpath $(SystemRoot))/System32
INSTALL_MAN3_DIR = $(MINGW_ROOT)/share/man/man3

#
# Flex/Yacc commands
#
FLEX = flex -P pcap_
YACC = bison -p pcap_

CFLAGS += -DHAVE_CONFIG_H -DHAVE_VERSION_H \
          -I. -I./Win32 -I./missing $(FORCE_INC)

ifeq ($(USE_WIN10PCAP),1)
  CFLAGS  += -I$(WIN10PCAP_ROOT)            \
             -I$(WIN10PCAP_ROOT)/Packet_dll \
             -DUSE_WIN10PCAP

  ifeq ($(HAVE_WANPACKET),1)
    CFLAGS += -I$(WINPCAP_ROOT)/PacketNtx/Dll
  endif

  RCFLAGS += -DUSE_WIN10PCAP

else ifeq ($(USE_NPCAP),1)
  CFLAGS += -I$(NPCAP_ROOT)                   \
            -I$(NPCAP_ROOT)/Common            \
            -I$(NPCAP_ROOT)/PacketWin7/Dll    \
            -DHAVE_PACKET_IS_LOOPBACK_ADAPTER \
            -DUSE_NPCAP                       \
            -DNPF_NPCAP_RUN_IN_WINPCAP_MODE   \
            -D__STRSAFE_GCC__383773443

  RCFLAGS += -DUSE_NPCAP

  ifeq ($(HAVE_WANPACKET),1)
    CFLAGS += -I$(NPCAP_ROOT)/PacketWin7/Dll/WanPacket
  endif

else
  CFLAGS += -I$(WINPCAP_ROOT)         \
            -I$(WINPCAP_ROOT)/Include \
            -I$(WINPCAP_ROOT)/PacketNtx/Dll
  RCFLAGS += -DUSE_WINPCAP
endif

ifeq ($(CC),gcc)
  #
  # Since some functions prototypes conflicts with those in the Win-SDK 8.0+,
  # we must pretend we're on Win-XP.
  #
  ifeq ($(USE_WIN10PCAP),0)
    #
    # For '#include <strsafe.h>'
    #
    CFLAGS += -I$(WINPCAP_ROOT)/Include/MinGW \
              -D__STRSAFE_GCC__383773443
  endif

  CFLAGS += -DEAFNOSUPPORT=WSAEAFNOSUPPORT
endif

#
# The targets with the '2' suffix are combinations of traditional
# libpcap + WinPcap + AirPcap.
#
TARGETS = $(WPCAP_DLL) $(WPCAP2_DLL) $(WPCAP_STAT_LIB) $(WPCAP2_STAT_LIB) $(WPCAP_IMP_LIB) $(WPCAP2_IMP_LIB)

#
# BIN_TARGETS: Targets that should be copied to $(INSTALL_BIN_DIR):
# LINK_CRAP:   Files to delete on 'make realclean':
#
BIN_TARGETS = $(WPCAP_DLL) $(WPCAP2_DLL)
LINK_CRAP   = $(WPCAP_DLL:.dll=.map) $(WPCAP2_DLL:.dll=.map)

ifeq ($(MSVC_TYPE),1)
  BIN_TARGETS += $(WPCAP_DLL:.dll=.pdb) $(WPCAP2_DLL:.dll=.pdb)
  LINK_CRAP   += $(WPCAP_DLL:.dll=.pdb) $(WPCAP2_DLL:.dll=.pdb) vc1*.pdb
endif

ifeq ($(USE_NPCAP),1)
  TARGETS     += NpcapHelperTest.exe
  BIN_TARGETS += NpcapHelperTest.pdb
  LINK_CRAP   += NpcapHelperTest.pdb

  $(OBJ_DIR)/NpcapHelperTest.$(O) \
  NpcapHelperTest.i:              CFLAGS += -DCOMPILING_NPCAPHELPERTEST_C

  ifeq ($(CC),clang-cl)
    $(OBJ_DIR)/NpcapHelperTest.$(O) \
    NpcapHelperTest.i:              CFLAGS += -Wno-format -Wno-bad-function-cast
  endif
endif


WPCAP_SRC = bpf_dump.c    \
            bpf_filter.c  \
            bpf_image.c   \
            charconv.c    \
            etherent.c    \
            fmtutils.c    \
            scanner.c     \
            grammar.c     \
            gencode.c     \
            nametoaddr.c  \
            optimize.c    \
            pcap.c        \
            pcap-common.c \
            pcap-npf.c    \
            pcap-namedb.c \
            savefile.c    \
            sf-pcap.c     \
            sf-pcapng.c   \
            missing/win_asprintf.c

#
# Don't add this for MSVC/clang since 'strtok_r' is a macro in portability.h.
#
ifeq ($(CC),gcc)
  WPCAP_SRC += missing/strtok_r.c
endif

#
# Old stuff:
#
ifeq (0,1)
  WPCAP_SRC += $(addprefix Win32/src/, \
                 getnetbynm.c          \
                 getnetent.c           \
                 getservent.c          \
                 inet_aton.c           \
                 inet_net.c            \
                 inet_pton.c)
endif

#
# Which Packet32 sources to use?
#
ifeq ($(USE_WIN10PCAP),1)
  FEATURES += "Win10Pcap by Daiyuu Nobori, "

  PACKET32_C_SRC = $(addprefix $(WIN10PCAP_ROOT)/Packet_dll/, \
                     Ms.c                                     \
                     NdisDriverUser.c                         \
                     Packet32.c                               \
                     SeMemory.c                               \
                     SeStr.c)                                 \
                   Win32/Win10pcap_hack.c

else ifeq ($(USE_NPCAP),1)
  FEATURES += "NPcap by Yang Luo, "

  #
  # All these must be compiled as UNICODE.
  #
  PACKET32_CPP_SRC = $(addprefix $(NPCAP_ROOT)/PacketWin7/Dll/, \
                       AdInfo.cpp                               \
                       Packet32.cpp                             \
                       ProtInstall.cpp                          \
                       netcfgapi.cpp)

  # PACKET32_C_SRC = Win32/WanPacket_imp.c
else
  PACKET32_C_SRC = $(addprefix $(WINPCAP_ROOT)/PacketNtx/Dll/, \
                     Packet32.c                                \
                     AdInfo.c)
endif

ifeq ($(CC),gcc)
  ifeq ($(USE_CRT_DEBUG),1)
    CFLAGS += -O0 -gcoff
  else
    CFLAGS += -O2 -ffast-math -fomit-frame-pointer
  endif
else

  ifeq ($(USE_CRT_STATIC),1)
    CRT = MT
  else
    CRT = MD
  endif

  ifeq ($(USE_CRT_DEBUG),1)
    FEATURES += "Debug build,"
    D = d
  else
    FEATURES += "Release build,"
    CFLAGS   += -DNDEBUG
    D =
  endif

  CFLAGS += -$(CRT)$(D)
endif

ifeq ($(USE_PACKET32_DEBUG),1)
  FEATURES += "Packet32.c tracing,"
  CFLAGS   += -D_DEBUG_TO_FILE
endif

#
# If '$(PCAP_DEBUG)=1 or =2':
#
#   1) Enable debug-code in optimize.c and testprogs/filtertest.c ('-DBDEBUG').
#
#   2) Enable more verbose debug-code in grammar.c ('-DYYDEBUG=1')
#      when $(PCAP_DEBUG) == 2.
#
#   3) Enables the 'PCAP_TRACE()' macro in "pcap-trace.h" thus
#      activating trace-code in pcap-trace.c and the plugins
#      in 'WinPcap-plugins/*.c'.
#
ifeq ($(PCAP_DEBUG),1)
  FEATURES += "PCAP_DEBUG=1,"
  CFLAGS += -DBDEBUG         \
            -DUSE_PCAP_TRACE \
            -DPCAP_DEBUG=1

  WPCAP_SRC  += pcap-trace.c
  RPCAPD_SRC += pcap-trace.c

else ifeq ($(PCAP_DEBUG),2)
  FEATURES += "YYDEBUG,"
  CFLAGS   += -DBDEBUG         \
              -DUSE_PCAP_TRACE \
              -DYYDEBUG=1

  WPCAP_SRC  += pcap-trace.c
  RPCAPD_SRC += pcap-trace.c
endif

ifeq ($(HAVE_NPFIM_API),1)
  FEATURES += "Microsoft Network Packet Filter,"

  ifeq ($(USE_NPCAP),1)
    PACKET32_CPP_SRC += $(NPCAP_ROOT)/PacketWin7/Dll/NpfImExt.cpp
  else
    PACKET32_C_SRC   += $(WINPCAP_ROOT)/PacketNtx/Dll/NpfImExt.c
  endif

  CFLAGS += -DHAVE_NPFIM_API \
            -I$(NETMON_ROOT)
endif

ifeq ($(HAVE_AIRPCAP),1)
  FEATURES += "AirPcap,"
  CFLAGS   += -DHAVE_AIRPCAP     \
              -DHAVE_AIRPCAP_API \
              -I$(AIRPCAP_ROOT)/include
endif

ifeq ($(HAVE_DAG_API),1)
  FEATURES += "Dag API,"
  CFLAGS   += -DHAVE_DAG_API \
              -I$(DAG_API_ROOT)/include
endif

ifeq ($(HAVE_PLUGINS),1)
  FEATURES    += "Plug-in support,"

  VPATH       += WinPcap-Plugins WinPcap-Plugins/example
  CFLAGS      += -DPCAP_SUPPORT_PLUGINS \
                 -I./WinPcap-Plugins

  PLUGIN_SRC  += WinPcap-Plugins/example/example_plugin.c
  WPCAP_SRC   += WinPcap-Plugins/pcap-plugin.c

  TARGETS     += WinPcap-Plugins/winpcap_example_plugin$(X64_SUFFIX).dll
  BIN_TARGETS += WinPcap-Plugins/winpcap_example_plugin$(X64_SUFFIX).dll
  LINK_CRAP   += WinPcap-Plugins/winpcap_example_plugin$(X64_SUFFIX).map

  ifeq ($(MSVC_TYPE),1)
    BIN_TARGETS += WinPcap-Plugins/winpcap_example_plugin$(X64_SUFFIX).pdb
    LINK_CRAP   += WinPcap-Plugins/winpcap_example_plugin$(X64_SUFFIX).pdb
  endif

  #
  # Currently MSVC/clang-cl only:
  #   Win-Vista is required to link and use
  #   winpcap_btooth_plugin$(X64_SUFFIX).dll
  #
  ifeq ($(HAVE_BLUETOOTH),1)
    FEATURES    += "BlueTooth plug-in,"
    CFLAGS      += -DHAVE_BLUETOOTH
    VPATH       += WinPcap-Plugins/Bluetooth
    PLUGIN_SRC  += WinPcap-Plugins/BlueTooth/win_btooth.c
    TARGETS     += WinPcap-Plugins/winpcap_btooth_plugin$(X64_SUFFIX).dll
    BIN_TARGETS += WinPcap-Plugins/winpcap_btooth_plugin$(X64_SUFFIX).dll
    LINK_CRAP   += WinPcap-Plugins/winpcap_btooth_plugin$(X64_SUFFIX).map

    ifeq ($(MSVC_TYPE),1)
      BIN_TARGETS += WinPcap-Plugins/winpcap_btooth_plugin$(X64_SUFFIX).pdb
      LINK_CRAP   += WinPcap-Plugins/winpcap_btooth_plugin$(X64_SUFFIX).pdb
    endif
  endif

  ifeq ($(HAVE_USB_PCAP),1)
    CFLAGS      += -DHAVE_USB_PCAP -I$(USBPCAP_ROOT)/USBPcapDriver/include
    FEATURES    += "USBPcap plug-in,"
    VPATH       += WinPcap-Plugins/USB-pcap
    PLUGIN_SRC  += $(addprefix WinPcap-Plugins/USB-pcap/, \
                     enum.c                               \
                     filters.c                            \
                     roothubs.c                           \
                     thread.c                             \
                     win_usbpcap.c)

    TARGETS     += WinPcap-Plugins/winpcap_usb_plugin$(X64_SUFFIX).dll
    BIN_TARGETS += WinPcap-Plugins/winpcap_usb_plugin$(X64_SUFFIX).dll
    LINK_CRAP   += WinPcap-Plugins/winpcap_usb_plugin$(X64_SUFFIX).map

    ifeq ($(MSVC_TYPE),1)
      BIN_TARGETS += WinPcap-Plugins/winpcap_usb_plugin$(X64_SUFFIX).pdb
      LINK_CRAP   += WinPcap-Plugins/winpcap_usb_plugin$(X64_SUFFIX).pdb
    endif
  endif

else
  #
  # If 'HAVE_PLUGIN=0' delete these on a 'make vclean' anyway.
  #
  LINK_CRAP += WinPcap-Plugins/winpcap_*.map \
               WinPcap-Plugins/winpcap_*.pdb
endif

ifeq ($(HAVE_PCAP_REMOTE),1)
  FEATURES += "Remote capture,"
  VPATH    += rpcapd
  CFLAGS   += -DLIBPCAP_REMOTE \
              -DENABLE_REMOTE
  RCFLAGS  += -I./rpcapd

  PACKET32_C_SRC += pcap-new.c pcap-rpcap.c sockutils.c rpcap-protocol.c
  WPCAP_SRC      += pcap-new.c pcap-rpcap.c sockutils.c rpcap-protocol.c

  TARGETS     += rpcapd/rpcapd$(X64_SUFFIX).exe
  BIN_TARGETS += rpcapd/rpcapd$(X64_SUFFIX).exe
  LINK_CRAP   += rpcapd/rpcapd$(X64_SUFFIX).map

  ifeq ($(MSVC_TYPE),1)
    BIN_TARGETS += rpcapd/rpcapd$(X64_SUFFIX).pdb
    LINK_CRAP   += rpcapd/rpcapd$(X64_SUFFIX).pdb
  endif

  ifeq ($(HAVE_OPENSSL),1)
    CFLAGS += -DHAVE_OPENSSL \
              -I$(OPENSSL_ROOT)/include

    WPCAP_SRC      += sslutils.c
    PACKET32_C_SRC += sslutils.c

    EX_LIBS += $(call lib_select, $(OPENSSL_ROOT)/lib32/libcrypto_imp.lib \
                                  $(OPENSSL_ROOT)/lib32/libssl_imp.lib,   \
                                  $(OPENSSL_ROOT)/lib32/libcrypto.dll.a   \
                                  $(OPENSSL_ROOT)/lib32/libssl.dll.a)
  endif

  RPCAPD_SRC += $(addprefix rpcapd/, \
                  rpcapd.c           \
                  daemon.c           \
                  fileconf.c         \
                  log.c              \
                  win32-svc.c)

  RPCAPD_SRC += sslutils.c \
                missing/getopt.c

  #
  # These .c-files are in $(WPCAP_STAT_LIB) if it was built with
  # 'ENABLE_REMOTE' I.e. 'HAVE_PCAP_REMOTE = 1.
  #
  # But if we use the $(WPCAP_IMP_LIB) library, the functions in those files
  # are not exported. Hence we must add the .$(O)-files when linking 'rpcapd.exe'
  #
  # An alternative would be to use a generated .def-files and add 'EXPORTS'
  # for these functions too (as I do for functions in 'wpcap2.dll').
  #
  RPCAPD_SRC += charconv.c       \
                fmtutils.c       \
                rpcap-protocol.c \
                sockutils.c

  RPCAPD_OBJ = $(call c_to_obj, $(RPCAPD_SRC))
  RPCAPD_I   = $(notdir $(RPCAPD_SRC:.c=.i))

  #
  # Extra CFLAGS for building 'rpcapd/rpcapd.exe'.
  #
  $(RPCAPD_OBJ) $(RPCAPD_I): CFLAGS += -DCOMPILING_RPCAPD_CODE -DPCAP_DLL

  #
  # We should possibly build the rpcap client DLL+program too?
  # Ref files in ./libpcap-apps/rpcap-0.23
  #
  # Or build 'rpcap' into WinPcap as a plugin?
  #
endif

ifeq ($(HAVE_TC_API),1)
  FEATURES  += "TurboCap,"
  WPCAP_SRC += pcap-tc.c
  CFLAGS    += -DHAVE_TC_API \
              -I$(TC_API_ROOT)/devpack/include
endif

ifeq ($(HAVE_WANPACKET),1)
  FEATURES       += "WAN support,"
  CFLAGS         += -DHAVE_WANPACKET_API
  PACKET32_C_SRC += Win32/WanPacket_imp.c
endif

ifeq ($(USE_DECNET),1)
  FEATURES  += "Decnet names,"
  VPATH     += $(DECNET_ROOT)/netdnet
  CFLAGS    += -DDECNETLIB -I$(DECNET_ROOT)
  WPCAP_SRC += $(DECNET_ROOT)/netdnet/getnodebyname.c
endif

ifeq ($(MAKE_MAN_PAGES),1)
  MAN3_PAGES  = $(wildcard *.3pcap.in) \
                $(wildcard *.3pcap)
  MAN3_PAGES := $(MAN3_PAGES:.3pcap.in=.3pcap)
  MAN3_PAGES := $(addprefix doc/, $(MAN3_PAGES:.3pcap=.3) pcap-savefile.3)
  MAN3_PAGES += $(addprefix doc/, pcap-filter.3 pcap-linktype.3 pcap-tstamp.3)

  #
  # Generated from 'rpcapd/rpcapd-config.manfile.in':
  #
  MAN3_PAGES += doc/rpcapd-config.3 \
                doc/rpcapd.3

  TARGETS += $(MAN3_PAGES)
endif

#
# At minimum, we need these external Windows libs:
#
EX_LIBS += $(call lib_select, \
              version.lib advapi32.lib iphlpapi.lib, \
             -lversion  -ladvapi32    -liphlpapi)

#
# Not needed for MinGW
#
EX_LIBS += $(call lib_select, user32.lib,)

ifeq ($(CC),gcc)
  EX_LIBS += -lws2_32

else ifeq ($(USE_WSOCK_TRACE),1)
  #
  # These MUST be in %LIB%-path.
  #
  ifeq ($(BITS),64)
    EX_LIBS += wsock_trace_x64.lib
  else
    EX_LIBS += wsock_trace.lib
  endif
else
  EX_LIBS += ws2_32.lib
endif

ifeq ($(USE_NPCAP),1)
  EX_LIBS += $(call lib_select, shell32.lib shlwapi.lib setupapi.lib, -lshlwapi -lsetupapi)

else ifeq ($(USE_WIN10PCAP),1)
  EX_LIBS += $(call lib_select, winmm.lib, -lwinmm)
endif

#
# And now the 'Packet.lib / libpacket.a' messy stuff.
#
ifeq ($(MSVC_TYPE),1)
  ifeq ($(USE_WIN10PCAP),1)
    #
    # This is a static-library for Win10Pcap's Packet code.
    #
    PACKET_LIB = $(WIN10PCAP_ROOT)/Packet_dll/Packet$(X64_SUFFIX).lib

  else ifeq ($(USE_NPCAP),1)
    #
    # Since NPcap has no Packet.lib to link to, we use the extra .$(O)-files.
    #
    PACKET_LIB =

  else
    #
    # This is an *import* library for CACE Tech's (Riverbed's) Packet.dll.
    #
    PACKET_LIB = $(WINPCAP_ROOT)/lib/$(LIB_SUBDIR)Packet.lib
  endif

else ifeq ($(CC),gcc)
  #
  # This is an *import* library for CACE Tech's (Riverbed's) Packet.dll.
  #
  # To create this (in case it doesn't exist), do:
  #   cd $(WINPCAP_ROOT)\PacketNtx\Dll\Project
  #   make CC="gcc -m32"
  #   make CC="gcc -m64"
  #
  PACKET_LIB = $(WINPCAP_ROOT)/lib/$(LIB_SUBDIR)libpacket.a
endif

#
# Put config.h under Win32 so that programs using libpcap is less
# likely to pick up the wrong "config.h" file.
#
GENERATED = Win32/config.h grammar.c grammar.h scanner.c scanner.h

all: intro $(GENERATED) $(OBJ_DIR) $(TARGETS) programs epilogue

intro:
	$(call green_msg, Building $(VERSION) (CC=$(CC)) with "$(FEATURES)")

epilogue:
	$(call green_msg, Welcome to libpcap $(BRIGHT_WHITE)(CC=$(CC), $(BITS)-bits).)
ifeq (,$(findstring install,$(MAKECMDGOALS)))
	$(call green_msg, Do a $(BRIGHT_WHITE)make CC=$(CC) -f $(THIS_FILE) install$(BRIGHT_GREEN) at own risk.)
endif

#
# These import libraries are generated by the 'link_DLL' rules for these .DLLs.
#
$(WPCAP_IMP_LIB):  $(WPCAP_DLL)
$(WPCAP2_IMP_LIB): $(WPCAP2_DLL)

#
# Because 'inet_ntop()' needs '_WIN32_WINNT >= 0x0600'.
#
$(OBJ_DIR)/findalldevstest.$(O) findalldevstest.i: CFLAGS += -U_WIN32_WINNT -D_WIN32_WINNT=0x0600

TEST_SRC = $(addprefix testprogs/,  \
             can_set_rfmon_test.c   \
             capturetest.c          \
             filtertest.c           \
             findalldevstest.c      \
             findalldevstest-perf.c \
             opentest.c             \
             threadsignaltest.c)

ifeq ($(USER),gv)
  TEST_SRC += testprogs/getadapters.c
endif

TEST_OBJ      = $(call c_to_obj, $(TEST_SRC))
TEST_I        = $(notdir $(TEST_OBJ:.c=.i))
TEST_PROGRAMS = $(notdir $(TEST_SRC:.c=.exe))

FUZZ_SRC = $(addprefix testprogs/fuzz/, \
             fuzz_both.c                \
             fuzz_filter.c              \
             fuzz_pcap.c                \
             onefile.c)

FUZZ_PROGRAMS = fuzz_both.exe fuzz_filter.exe fuzz_pcap.exe

$(OBJ_DIR)/Packet32.$(O) \
$(OBJ_DIR)/AdInfo.$(O):  CFLAGS += -DCOMPILING_PACKET32_C

ifeq ($(HAVE_PLUGINS),1)
  PLUGIN_OBJ = $(call c_to_obj, $(PLUGIN_SRC))
  PLUGIN_I   = $(notdir $(PLUGIN_SRC:.c=.i))

  $(PLUGIN_OBJ) $(PLUGIN_I): CFLAGS += -DCOMPILING_PCAP_PLUGIN
endif

ifeq ($(CC),clang-cl)
  #
  # Some of the $(PACKET32_C_SRC) sources generates tons of warnings.
  #
  $(OBJ_DIR)/Packet32.$(O)    \
  $(OBJ_DIR)/AdInfo.$(O)      \
  $(OBJ_DIR)/ProtInstall.$(O) \
  Packet32.i                  \
  AdInfo.i                    \
  ProtInstall.i: CFLAGS += -Wno-bad-function-cast             \
                           -Wno-incompatible-pointer-types    \
                           -Wno-sign-compare                  \
                           -Wno-documentation-unknown-command \
                           -Wno-zero-as-null-pointer-constant \
                           -Wno-deprecated-declarations       \
                           -Wno-c++98-compat-pedantic         \
                           -Wno-writable-strings

  ifeq ($(USE_NPCAP),1)
    #
    # Contrary to it's name; '$(NPCAP_ROOT)/PacketWin7/Dll/AdInfo.cpp', this
    # file MUST be compiled as a .c-file. But only when 'HAVE_WANPACKET_API'
    # is used. But it needs external C++ symbols. Hence 'HAVE_WANPACKET_API'
    # is impossible with NPcap. See above.
    #
    # $(OBJ_DIR)/AdInfo.$(O): CFLAGS += -TC

    #
    # '$(NPCAP_ROOT)/PacketWin7/Dll/Packet32.cpp' breaks some C++ rules.
    #
    $(OBJ_DIR)/Packet32.$(O): CFLAGS += -Wno-exit-time-destructors \
                                        -Wno-global-constructors
  endif

  #
  # Some testprogs/*.c files uses deprecated libpcap functions. Ignore that.
  #
  $(TEST_OBJ) $(TEST_I): CFLAGS += -Wno-deprecated-declarations
endif

#
# If using Win10Pcap I have to use the Wpcap import-library due to this mysterious link error:
#   unresolved external symbol __pRawDllMain
#
# Otherwise (USE_WIN10PCAP=0), let these test programs link to the static library.
#
ifeq ($(USE_WIN10PCAP),1)
  WPCAP_LIB = $(WPCAP_IMP_LIB)
else
  WPCAP_LIB = $(WPCAP_STAT_LIB)
endif

filtertest.exe: $(OBJ_DIR)/filtertest.$(O) $(OBJ_DIR)/getopt.$(O) $(WPCAP_LIB)
	$(call link_EXE, $@, $^ $(PACKET_LIB) $(EX_LIBS))

findalldevstest.exe: $(OBJ_DIR)/findalldevstest.$(O) $(WPCAP_LIB)
	$(call link_EXE, $@, $^ $(PACKET_LIB) $(EX_LIBS))

findalldevstest-perf.exe: $(OBJ_DIR)/findalldevstest-perf.$(O) $(WPCAP_LIB)
	$(call link_EXE, $@, $^ $(PACKET_LIB) $(EX_LIBS))

getadapters.exe: $(OBJ_DIR)/getadapters.$(O) $(OBJ_DIR)/pcap-trace.$(O)
	$(call link_EXE, $@, $^ $(call sys_libs, iphlpapi.lib))

opentest.exe: $(OBJ_DIR)/opentest.$(O) $(OBJ_DIR)/getopt.$(O) $(WPCAP_LIB)
	$(call link_EXE, $@, $^ $(PACKET_LIB) $(EX_LIBS))

threadsignaltest.exe: $(OBJ_DIR)/threadsignaltest.$(O) $(OBJ_DIR)/getopt.$(O) $(WPCAP_LIB)
	$(call link_EXE, $@, $^ $(PACKET_LIB) $(EX_LIBS))

fuzz_%.exe: $(OBJ_DIR)/fuzz_%.$(O) $(OBJ_DIR)/onefile.$(O) $(WPCAP_LIB)
	$(call link_EXE, $@, $^ $(PACKET_LIB) $(EX_LIBS))

#
# The rest can use the Wpcap import library with all combinations of
# 'USE_WIN10PCAP' or 'USE_NPCAP'.
#
capturetest.exe: $(OBJ_DIR)/capturetest.$(O) $(OBJ_DIR)/getopt.$(O) $(WPCAP_IMP_LIB)
	$(call link_EXE, $@, $^)

can_set_rfmon_test.exe: $(OBJ_DIR)/can_set_rfmon_test.$(O) $(WPCAP_IMP_LIB)
	$(call link_EXE, $@, $^)

rpcapd/rpcapd$(X64_SUFFIX).exe: $(RPCAPD_OBJ) $(OBJ_DIR)/rpcapd.res $(WPCAP_IMP_LIB)
	$(call link_EXE, $@, $^ $(EX_LIBS))

NpcapHelperTest.exe: $(OBJ_DIR)/NpcapHelperTest.$(O) $(OBJ_DIR)/pcap-trace.$(O) # $(OBJ_DIR)/NpcapHelperTest.res
	$(call link_EXE, $@, $^ advapi32.lib shell32.lib)

#
# Rules to link the 'WinPcap-Plugins/winpcap_*.dll' plugins:
#
WinPcap-Plugins/winpcap_example_plugin$(X64_SUFFIX).dll: $(OBJ_DIR)/example_plugin.$(O) \
                                                         $(OBJ_DIR)/pcap-trace.$(O)     \
                                                         $(OBJ_DIR)/example_plugin.res
	$(call link_plugin_DLL, $@, $^)

WinPcap-Plugins/winpcap_btooth_plugin$(X64_SUFFIX).dll:  $(OBJ_DIR)/win_btooth.$(O) \
                                                         $(OBJ_DIR)/pcap-trace.$(O) \
                                                         $(OBJ_DIR)/win_btooth.res
	$(call link_plugin_DLL, $@, $^ $(call sys_libs, bthprops.lib setupapi.lib))

WinPcap-Plugins/winpcap_usb_plugin$(X64_SUFFIX).dll:     $(OBJ_DIR)/win_usbpcap.$(O) \
                                                         $(OBJ_DIR)/pcap-trace.$(O)  \
                                                         $(OBJ_DIR)/enum.$(O)        \
                                                         $(OBJ_DIR)/filters.$(O)     \
                                                         $(OBJ_DIR)/roothubs.$(O)    \
                                                         $(OBJ_DIR)/thread.$(O)      \
                                                         $(OBJ_DIR)/win_usbpcap.res
	$(call link_plugin_DLL, $@, $^ $(call sys_libs, hid.lib setupapi.lib comdlg32.lib advapi32.lib cfgmgr32.lib shlwapi.lib))


######################################################################################

define CONFIG_H
  #ifndef _libpcap_CONFIG_H
  #define _libpcap_CONFIG_H

  #define INET6
  #define HAVE_LIMITS_H
  #define HAVE_STRERROR
  #define HAVE_SOCKADDR_STORAGE
  #define HAVE_IPHELPER_API
  #define HAVE_PACKET32
  #define HAVE__WCSERROR_S

  #define _CRT_NONSTDC_NO_WARNINGS
  #define _CRT_SECURE_NO_WARNINGS
  #define _CRT_OBSOLETE_NO_WARNINGS

  #if defined(USE_NPCAP)
    #if !defined(COMPILING_PCAP_PLUGIN) && (defined(_MSC_VER) || defined(__clang__))
      /*
       * Must force-include this as "WindowsKit/xx/shared/strsafe.h" since
       * "./NPcap/PacketWin7/Dll" MUST be in the include list!!
       */
      #include "$(realpath $(WK_ROOT))/include/$(WK_VER)/shared/strsafe.h"

      #ifdef __cplusplus
      #include <string>
      #endif

      #ifdef UNICODE
        #define StringCchPrintf StringCchPrintfW
      #else
        #define StringCchPrintf StringCchPrintfA
      #endif
    #endif   /* _MSC_VER) && !COMPILING_PCAP_PLUGIN */

  #elif defined(USE_WIN10PCAP)
    #include <stdbool.h>

    #define WIN32COM_CPP

  #else     /* 'USE_NPCAP = 0' && 'USE_WIN10PCAP = 0' */

    /*
     * Npcap's "packetWin7/Dll/Packet32.c" needs <shellapi.h> which
     * is not included if 'WIN32_LEAN_AND_MEAN' defined.
     */
    #undef  WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
  #endif

  /* If this config.h was included from 'rpcap/' .c / .rc files.
   */
  #if defined(COMPILING_RPCAPD_CODE)
    #include <string.h>

    #undef  _WIN32_WINNT
    #define _WIN32_WINNT            _WIN32_WINNT_VISTA  /* Needed for 'inet_ntop()' */
    #define MINGW_HAS_SECURE_API    1

    #define PACKAGE_VERSION        "1.0"
    #define PACKAGE_VERSION_DLL     1,0,0,0

  #else
    #define PACKAGE_NAME            "pcap"
    #define PACKAGE_VERSION         "libpcap version $(VERSION)"
    #define PCAP_PLUGIN_VERSION      1,0,0,0
  #endif

  #if !defined(RC_INVOKED)
    /*
     * To ignore warnings like:
     *   ./WinPcap/PacketNtx/Dll/Packet32.c(1275): warning C4996:
     *   'GetVersion': was declared deprecated
     *   f:\ProgramFiler-x86\MS-SDK-8.1\Include\um\sysinfoapi.h(110): note: see declaration of 'GetVersion'
     */
    #define BUILD_WINDOWS 1

    #if defined(USE_VLD)
    #include <vld.h>
    #endif
  #endif

  /*
   * To ignore warnings like:
   *   warning C4996: 'inet_ntoa': Use inet_ntop() or InetNtop() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS
   *                   to disable deprecated API warnings
   */
  #define _WINSOCK_DEPRECATED_NO_WARNINGS 1

//#define ENABLE_WLAN_FILTERING_PATCH 1

  #if defined(__MINGW32__)
    #define STRSAFE_NO_DEPRECATE 1
    #define MINGW_HAS_SECURE_API 1
    #define HAVE_STRTOK_R        1
  #endif

  #if defined(_MSC_VER) || defined(__clang__)
    #define YY_NO_UNISTD_H
    #define YY_USE_CONST

    /*
     * Since MSVC 2013 only runs on WinVista (and higher), we can
     * safely ass-u-me this.
     */
    #if (_MSC_VER >= 1800) && !defined(_WIN32_WINNT) && !defined(WINVER) // && !defined(COMPILING_WIN10PCAP)
      #undef  _WIN32_WINNT
      #define _WIN32_WINNT    0x0600
      #undef  WINVER
      #define WINVER          0x0600
      #undef  NTDDI_VERSION
      #define NTDDI_VERSION   NTDDI_VISTA   /* = (0x0600 << 16) */
    #endif

    #if defined(_M_X64) || defined(_M_IA64) || defined(_M_AMD64)
      #pragma warning (disable:4267)  /* conversion from 'size_t' to 'u_int', possible loss of data */
    #endif
  #endif

  #if defined(__MINGW32__) || defined(__WATCOMC__)
    #include <inttypes.h>

    #define u_int8_t   uint8_t
    #define u_int16_t  uint16_t
    #define u_int32_t  uint32_t
    #define u_int64_t  uint64_t
  #endif

  /*
   * Since '$(WINPCAP_ROOT)/PacketNtx/Dll/Packet32.c' and '$(WINPCAP_ROOT)/PacketNtx/Dll/AdInfo.c'
   * has a '#define UNICODE', it must include <windows.h> after that line.
   */
  #if !defined(COMPILING_PACKET32_C) || 1
    #include <winsock2.h>
    #include <windows.h>
  #endif

  #if defined(COMPILING_WIN10PCAP)
    #include <ws2tcpip.h>
    #include <netioapi.h>
  #endif

  #if defined(COMPILING_AIRPCAP)
    #define OUT
    #define IN

    typedef struct _AIRPCAP_TX_HEADER {
            DWORD Flags;
            DWORD Power;
            DWORD Rate;
            DWORD Length;
          } AIRPCAP_TX_HEADER, *PAIRPCAP_TX_HEADER;
  #endif

  #include <stdint.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <malloc.h>
  #include <string.h>
  #include <time.h>

  #if defined(_DEBUG) && (defined(_MSC_VER) || defined(__clang__))
    #undef  _malloca            /* Avoid MSVC-9 <malloc.h>/<crtdbg.h> name-clash */
    #define _CRTDBG_MAP_ALLOC
    #include <crtdbg.h>
  #endif

  extern void crtdbug_init (void);

  #if defined(__WATCOMC__)
    #define _TRUNCATE 0
    #define _vsnprintf_s(str, size, flag, format, args) vsnprintf_s (str, size, format, args)
  #endif

  #define YYMALLOC        malloc
  #define YYFREE          free
  #define YYTEXT_POINTER  1

  extern int ffs (int mask);

  #if defined(RC_INVOKED)
    #if !defined(COMPILING_RPCAPD_CODE)
      #if defined(__clang__)
        #define RC_HOST "clang"

      #elif defined(_MSC_VER)
        #define RC_HOST "MSVC"

      #elif defined(__MINGW32__)
        #define RC_HOST "MinGW"

      #else
        #error "Who are you?"
      #endif

      #if defined(USE_NPCAP)
        #include "$(NPCAP_ROOT)/version.h"

        #define WINPCAP_DESCRIPTION       "NPcap Network Capture Library"
        #define WINPCAP_URL               "https://github.com/nmap/npcap/"

      #elif defined(USE_WIN10PCAP)
        #define WINPCAP_MAJOR  10
        #define WINPCAP_MINOR  2
        #define WINPCAP_REV    0
        #define WINPCAP_BUILD  5002

        #define WINPCAP_COPYRIGHT_STRING  "Copyright (C) 2015 Daiyuu Nobori, University of Tsukuba, Japan"
        #define WINPCAP_COMPANY_NAME      "Daiyuu Nobori"
        #define WINPCAP_DESCRIPTION       "Win10Pcap Network Capture Library"
        #define WINPCAP_URL               "https://github.com/SoftEtherVPN/Win10Pcap/"

      #else
        #include "$(WINPCAP_ROOT)/version.h"

        #define WINPCAP_DESCRIPTION       "WinPcap Network Capture Library"
        #define WINPCAP_URL               "http://www.winpcap.org/"
      #endif
    #endif   /* COMPILING_RPCAPD_CODE */

  #else
    /*
     * Include this only here.
     */
    #include "pcap-trace.h"
  #endif     /* RC_INVOKED */
  #endif     /* _libpcap_CONFIG_H */
endef

define WPCAP_RC
  #include <winver.h>
  #include "Win32/config.h"

  #define _STR2(x)  #x
  #define _STR(x)   _STR2(x)
  #define _STR_VER  _STR(WINPCAP_MAJOR) "." _STR(WINPCAP_MINOR) "." _STR(WINPCAP_REV) "." _STR(WINPCAP_BUILD)

  #define WINPCAP_RC_VERSION  WINPCAP_MAJOR, WINPCAP_MINOR, WINPCAP_REV, WINPCAP_BUILD

  LIBPCAP_ICON ICON "libpcap.ico"

  VS_VERSION_INFO VERSIONINFO
    FILEVERSION      WINPCAP_RC_VERSION
    PRODUCTVERSION   WINPCAP_RC_VERSION
    FILEFLAGSMASK    0x3FL
    FILEOS           VOS__WINDOWS32
    FILETYPE         VFT_DLL
    FILEFLAGS        0

  BEGIN
    BLOCK "StringFileInfo"
    BEGIN
      BLOCK "000004b0"
      BEGIN
        VALUE "Comments",         "https://github.com/the-tcpdump-group/libpcap/"
        VALUE "CompanyName",      "The TCPdump Group"
        VALUE "FileDescription",  "System-Independent Interface for User-Level Packet Capture (over " WINPCAP_DESCRIPTION ")"
        VALUE "InternalName",     PACKAGE_NAME
        VALUE "LegalCopyright",   "Copyright (c) The TCPdump Group"
        VALUE "LegalTrademarks",  ""
        VALUE "OriginalFilename", RC_DLL_NAME
        VALUE "PrivateBuild",     "G. Vanem's private build of $(TODAY)"
        VALUE "ProductName",      RC_DLL_NAME " (" RC_HOST ", $(BITS)-bit)"
        VALUE "ProductVersion",   PACKAGE_VERSION  // _STR_VER
        VALUE "FileVersion",      _STR_VER
        VALUE "SpecialBuild",     "$(FEATURES)"
      END
    END

    BLOCK "VarFileInfo"
    BEGIN
      VALUE "Translation", 0, 1200
    END
  END
endef

#
# Objects for wpcap.lib, libwpcap.a and wpcap.dll.
#
WPCAP_OBJ = $(call c_to_obj, $(WPCAP_SRC))

PACKET32_C_OBJ = $(call c_to_obj,   $(PACKET32_C_SRC))
PACKET32_I     = $(notdir $(PACKET32_C_OBJ:.$(O)=.i))
WPCAP_I        = $(notdir $(WPCAP_OBJ:.$(O)=.i))

ifeq ($(USE_NPCAP),1)
  PACKET32_CPP_OBJ = $(call cpp_to_obj, $(PACKET32_CPP_SRC))
  PACKET32_CPP_I   = $(notdir $(PACKET32_CPP_OBJ:.$(O)=.i))
endif

ifeq ($(USE_NPCAP),1)
  #
  # We MUST add these to the link of wpcap.dll since NPcap
  # has no Packet.lib to link to.
  #
  WPCAP_OBJ += $(PACKET32_CPP_OBJ) \
               $(OBJ_DIR)/WanPacket_imp.$(O)
endif

#
# Combined objects and .i-files for wpcap2.lib, libwpcap2.a and wpcap2.dll.
#
WPCAP2_OBJ = $(WPCAP_OBJ) $(PACKET32_C_OBJ) $(PACKET32_CPP_OBJ)
WPCAP2_I   = $(WPCAP_I)   $(PACKET32_I)     $(PACKET32_CPP_I)

ifeq ($(CC),gcc)
$(WPCAP_DLL): $(WPCAP_OBJ) $(OBJ_DIR)/wpcap.res
	$(call link_DLL, $@, $(WPCAP_IMP_LIB), $^ $(PACKET_LIB) $(EX_LIBS))

  #
  # Since functions in Packet32.c are NOT marked as
  # DLL-export, we force exports by a generated .def-file.
  #
$(WPCAP2_DLL): $(WPCAP2_OBJ) $(OBJ_DIR)/wpcap2.res $(OBJ_DIR)/wpcap2.def
	$(call link_DLL, $@, $(WPCAP2_IMP_LIB), $^ $(EX_LIBS))

else
$(WPCAP_DLL): $(WPCAP_OBJ) $(OBJ_DIR)/wpcap.res
	$(call link_DLL, $@, $(WPCAP_IMP_LIB), \
	                 $^ $(PACKET_LIB) $(EX_LIBS))

$(WPCAP2_DLL): $(WPCAP2_OBJ) $(OBJ_DIR)/wpcap2.res $(OBJ_DIR)/wpcap2.def
	$(call link_DLL, $@, $(WPCAP2_IMP_LIB), \
	                 $(WPCAP2_OBJ) $(OBJ_DIR)/wpcap2.res $(EX_LIBS) -def:$(OBJ_DIR)/wpcap2.def)
endif

#
# Since the 'dflag' variable (which is not exported in the wpcap.dll)
# is used in testprogs/filtertest.c, we are forced to use the static library
# wpcap2.lib for this test program.
# But only if '$(PCAP_DEBUG) >= 1' and when 'USE_WIN10PPAP = 1' (see above).
#
# The 'dflag' exist only in a COMDEF data-section; "Uninitialized common data".
#
ifeq ($(PCAP_DEBUG),0)
$(TEST_OBJ) $(TEST_I): CFLAGS += -DPCAP_DLL

else ifeq ($(USE_WIN10PCAP),1)
$(TEST_OBJ) $(TEST_I): CFLAGS += -DPCAP_DLL
endif

#
# When building the .c-files for the wpcap*.lib (i.e. $(WPCAP_OBJ) and $(WPCAP2_OBJ)),
# the '#define pcap_EXPORTS' must be set. Ref. "Win32/config.h" below.
#
$(WPCAP_OBJ) $(WPCAP2_OBJ) \
$(WPCAP_I)   $(WPCAP2_I):  CFLAGS += -Dpcap_EXPORTS -DBUILDING_PCAP


#
# This plugin needs some Vista+ functions:
#
$(OBJ_DIR)/win_btooth.$(O) win_btooth.i: CFLAGS += -U_WIN32_WINNT -D_WIN32_WINNT=0x0600

LINK_CRAP += $(TEST_PROGRAMS:.exe=.map) $(FUZZ_PROGRAMS:.exe=.map)

ifeq ($(MSVC_TYPE),1)
  LINK_CRAP += $(TEST_PROGRAMS:.exe=.pdb) \
               $(FUZZ_PROGRAMS:.exe=.pdb)
endif

ALL_SOURCES = $(PACKET32_C_SRC)   \
              $(PACKET32_CPP_SRC) \
              $(WPCAP_SRC)        \
              $(TEST_SRC)         \
              $(PLUGIN_SRC)       \
              $(RPCAPD_SRC)       \
              $(FUZZ_SRC)

##################################################################################

install: all
	cp --update $(BIN_TARGETS) $(INSTALL_BIN_DIR)
ifeq ($(MAKE_MAN_PAGES),1)
	@echo
	cp --update $(MAN3_PAGES)  $(INSTALL_MAN3_DIR)
endif

help:
	$(call green_msg, $$Usage)
	$(call green_msg0,  The $(BRIGHT_WHITE)all$(BRIGHT_GREEN) target will have these features:)
	$(call green_msg0,    $(FEATURES))

programs: $(TEST_PROGRAMS)
fuzzers:  $(FUZZ_PROGRAMS)

$(OBJ_DIR):
	-mkdir $@

#
# Static lib rules.
# Import-lib rules are in respective Makefiles.
#
wpcap$(X64_SUFFIX)_static.lib: $(WPCAP_OBJ)
	lib -nologo -out:$@ $^
	@echo

wpcap2$(X64_SUFFIX)_static.lib: $(WPCAP2_OBJ)
	lib -nologo -out:$@ $^
	@echo

wpcap_wc.lib: $(WPCAP_OBJ)
	wlib -q -b -c $@ +-$(WPCAP_OBJ:.$(O)=.$(O) +-)
	@echo

wpcap2_wc.lib: $(WPCAP2_OBJ)
	wlib -q -b -c $@ +-$(WPCAP2_OBJ:.$(O)=.$(O) +-)
	@echo

libwpcap$(X64_SUFFIX)_static.a: $(WPCAP_OBJ)
	ar rs $@ $^
	@echo

libwpcap2$(X64_SUFFIX)_static.a: $(WPCAP2_OBJ)
	ar rs $@ $^
	@echo

scanner.h: scanner.c
grammar.h: grammar.c

scanner.c: scanner.l grammar.c
	$(FLEX) --header-file=scanner.h --outfile=$@ $<
	@echo

grammar.c: grammar.y
	$(YACC) --yacc --output=$@ --defines=grammar.h $<
	@echo

Win32/config.h: $(THIS_FILE) ./VERSION
	$(call Generate_file, $@)
	$(file >> $@,$(CONFIG_H))
	@echo

ifeq ($(USE_WIN10CAP),1)
  WIN10PCAP_OBJ = $(addprefix $(OBJ_DIR)/, \
                    Ms.$(O)                \
                    NdisDriverUser.$(O)    \
                    Packet32.$(O)          \
                    SeMemory.$(O)          \
                    SeStr.$(O))

  WIN10PCAP_I = $(notdir $(WIN10PCAP_OBJ:.$(O)=.i))

  $(WIN10PCAP_OBJ) $(WIN10PCAP_I): CFLAGS += -DCOMPILING_WIN10PCAP
endif

#
# These MUST be compiled for Unicode.
#
ifeq ($(USE_NPCAP),1)
  $(PACKET32_CPP_OBJ) $(PACKET32_CPP_I): CFLAGS += -D_UNICODE -DUNICODE
endif

#
# A lot faster this way. But will compile too many files unneeded.
#
ifeq ($(USE_MP_COMPILE),1)
$(WPCAP_OBJ): $(WPCAP_SRC)
	$(call C_compile, -MP $(WPCAP_SRC), $(OBJ_DIR)\\)
endif

$(OBJ_DIR)/%.$(O): %.c
	$(call C_compile, $<, $@)

$(OBJ_DIR)/%.$(O): %.cpp
	$(call CPP_compile, $<, $@)

#
# Rule to create a nicer preprocessed .i file from a .c file.
# Uses the Python script 'cpp_filter.py' (generated below) and
# optionally 'GNU-indent' or 'clang-format'.
#
%.i: %.c FORCE cpp_filter.py Win32/config.h
	$(call C_preprocess, $<) > $@
	@echo

%.i: %.cpp FORCE cpp_filter.py Win32/config.h
	$(call CPP_preprocess, $<) > $@
	@echo

FORCE:

#
# arg1: $(1): name of .lib file to check for symbols
# Not used!
#
define check_lib_symbols
  nm --defined-only --print-file-name $(1) 2> NUL | grep -e ' T pcap' -e ' T bpf'
endef

##################################################################################

FEATURES := $(subst ",,$(FEATURES))

$(OBJ_DIR)/%.res: $(OBJ_DIR)/%.rc
	$(call make_res, $<, $@)

$(OBJ_DIR)/%.res: %.rc
	$(call make_res, $<, $@)

$(OBJ_DIR)/airpcap.res: $(AIRPCAP_ROOT)/src/version.rc
	$(call make_res, -I $(AIRPCAP_ROOT)/src $<, $@)

$(OBJ_DIR)/rpcapd.res: rpcapd/rpcapd.rc
	$(call make_res, -I./Win32 -DCOMPILING_RPCAPD_CODE $<, $@)

$(OBJ_DIR)/wpcap.rc: $(THIS_FILE)
	$(call Generate_file, $@)
	$(file >> $@, #define RC_DLL_NAME "$(WPCAP_DLL)")
	$(file >> $@,$(WPCAP_RC))
	@echo

$(OBJ_DIR)/wpcap2.rc: $(THIS_FILE)
	$(call Generate_file, $@)
	$(file >> $@, #define RC_DLL_NAME "$(WPCAP2_DLL)")
	$(file >> $@,$(WPCAP_RC))
	@echo

$(OBJ_DIR)/wpcap2.def: $(THIS_FILE)
	$(call green_msg, Generating $@ ...)
	$(file  > $@, ;)
	$(file >> $@, ; Generated $@ for MinGW, MSVC and clang-cl.)
	$(file >> $@, ; DO NOT EDIT. Edit $(realpath $(THIS_FILE)))
	$(file >> $@, ; and/or $(realpath $(THIS_FILE)) instead.)
	$(file >> $@, ;)
	$(file >> $@,$(WPCAP2_DEF))
ifeq ($(USE_NPCAP),1)
	$(file >> $@,  PacketGetDriverName)
	$(file >> $@,  PacketGetMonitorMode)
	$(file >> $@,  PacketIsLoopbackAdapter)
	$(file >> $@,  PacketIsMonitorModeSupported)
	$(file >> $@,  PacketSetMonitorMode)
endif
	@echo

####### C-COMPILE MACROS  #############################################
#
# arg1, $(1): The .c-file.
# arg2, $(2): The object file.
#
# For gcc/MinGW it is assumed your gcc is dual-mode.
# I.e. TDM-gcc or MinGW64-w64.
#
define C_compile
  $(call C_compile_$(CC), $(1), $(2))
  @echo
endef

C_compile_cl       = $(CL_CC) -c $(CFLAGS) -Fo./$(strip $(2)) $(1)
C_compile_clang-cl = $(CC)    -c $(CFLAGS) -Fo./$(strip $(2)) $(1)
C_compile_gcc      = $(CC)    -c $(CFLAGS) -o $(2) $(1)

###### C++ COMPILE MACROS  ###########################################
#
# arg1, $(1): The .cpp-file.
# arg2, $(2): The object file.
#
define CPP_compile
  $(call CPP_compile_$(CC), $(1), $(2))
  @echo
endef

CPP_compile_cl       = $(call C_compile_cl,       -EHsc $(1), $(2))
CPP_compile_clang-cl = $(call C_compile_clang-cl, -EHsc $(1), $(2))
CPP_compile_gcc      = $(call C_compile_gcc,      -x c++ $(1), $(2))

###### C/C++ preprocessing macros  #####################################
#
# Ref the '%.i: %.c' rule above.
# arg1, $(1): The .c/.cpp-file.
#
C_preprocess_cl       = $(CL_CC) -E $(CFLAGS)
C_preprocess_gcc      = $(CC) -E $(CFLAGS)
C_preprocess_clang-cl = $(CC) -E $(CFLAGS)
C_preprocess          = $(C_preprocess_$(CC)) $(1) | $(PYTHON) cpp_filter.py
CPP_preprocess        = $(C_preprocess_$(CC)) $(1) | $(PYTHON) cpp_filter.py

ifeq ($(USE_GNU_INDENT),1)
  C_preprocess += | indent -st

else ifeq ($(USE_CLANG_FORMAT),1)
  C_preprocess   += | clang-format -style=Mozilla -assume-filename=c
  CPP_preprocess += | clang-format -style=Mozilla -assume-filename=cpp
endif

####### LINK MACRO (DLL + imp-lib) ####################################
#
# arg1, $(1): The name of the produced DLL.
# arg2, $(2): The name of the import lib.
# arg3, $(3): The rest of the link arguments.
#
define link_DLL
  $(call green_msg, Linking $(1))
  $(call link_DLL_$(CC), $(1), $(2), $(3))
  touch $(2)
  @echo
endef

define link_DLL_cl
  $(CL_LINK) $(LDFLAGS) -dll -out:$(strip $(1)) -implib:$(strip $(2)) \
             $(CL_LIBS) $(3) > link.tmp
  @cat link.tmp >> $(1:.dll=.map)
  @rm -f link.tmp $(1:.dll=.exp)
endef

link_DLL_clang-cl = $(call link_DLL_cl, $(1), $(2), $(3))
link_DLL_gcc      = $(CC) $(LDFLAGS) -shared -o $(1) -Wl,--out-implib,$(strip $(2)) $(3) > $(1:.dll=.map)

define create_rsp_file
  $(file > $(1))
  $(foreach f, $(2), $(file >> $(1),$(strip $(f))) )
endef

####### LINK MACRO for Plugin DLLs, no imp-lib ########################
#
# arg1, $(1): The name of the produced DLL.
# arg2, $(2): The rest of the link arguments.
#
define link_plugin_DLL
  $(call green_msg, Linking $(strip $(1)))
  $(call link_plugin_DLL_$(CC), $(1), $(2))
  @echo
endef

define link_plugin_DLL_cl
  $(CL_LINK) $(LDFLAGS) -dll -out:$(strip $(1)) $(2) $(CL_LIBS) > link.tmp
  @cat link.tmp >> $(1:.dll=.map)
  @rm -f link.tmp $(1:.dll=.lib) $(1:.dll=.exp)
endef

link_plugin_DLL_clang-cl = $(call link_plugin_DLL_cl, $(1), $(2))
link_plugin_DLL_gcc      = $(CC) $(LDFLAGS) -shared -o $(1) $(2) > $(1:.dll=.map)

####### LINK MACRO (EXE) ##############################################
#
# arg1, $(1): The name of the produced EXE.
# arg2, $(2): The rest of the link arguments.
#
define link_EXE
  $(call green_msg, Linking $(strip $(1)))
  $(call link_EXE_$(CC), $(1), $(2))
  @echo
endef

define link_EXE_cl
  $(CL_LINK) $(LDFLAGS) $(CL_LIBS) -out:$(strip $(1)) $(2) > link.tmp
  @cat link.tmp >> $(1:.exe=.map)
  @rm -f link.tmp $(1:.exe=.exp) $(1:.exe=.lib)
endef

link_EXE_clang-cl = $(call link_EXE_cl, $(1), $(2))
link_EXE_gcc      = $(CC) $(LDFLAGS) -o $(1) $(2) > $(1:.exe=.map)

####### MAKE RESOURCE (RES) ###########################################
#
# arg1, $(1): The output .RES.
# arg2, $(2): The input .RC file.
#
make_res_cl       = rc -nologo -fo $(2) $(1)
make_res_clang-cl = rc -nologo -fo $(2) $(1)
make_res_gcc      = windres -O COFF -fo $(2) $(1)

define make_res
  $(call make_res_$(CC), $(RCFLAGS) $(1), $(2))
  @echo
endef

#
# Create a file with header.
#   $(1): file to write to.
#
define Generate_file
  $(call green_msg, Generating $(1) ...)
  $(file  > $(1), /*)
  $(file >> $(1),  * Generated $(strip $(1)) for MinGW, MSVC and clang-cl at $(TODAY).)
  $(file >> $(1),  * DO NOT EDIT!)
  $(file >> $(1),  * Edit $(realpath $(THIS_FILE)) instead.)
  $(file >> $(1),  */)
endef

#
# Replace all this cruft in man-files.
# @MAN_MISC_INFO@ is unimportant on Win32.
#
MAN_SED_REPLACE = -e 's/@MAN_FILE_FORMATS@/ 3/g' \
	              -e 's/@MAN_MISC_INFO@/ 3/g'    \
	              -e 's/@MAN_ADMIN_COMMANDS@/ 1m/g'

doc/%.3: %.3pcap.in
	sed $(MAN_SED_REPLACE) < $< > $@

doc/%.3: %.3pcap
	cp $^ $@

doc/rpcapd-config.3: rpcapd/rpcapd-config.manfile.in
	sed $(MAN_SED_REPLACE) < $< > $@

doc/%.3: %.manmisc.in
	sed $(MAN_SED_REPLACE) < $< > $@

doc/rpcapd.3: rpcapd/rpcapd.manadmin.in
	sed $(MAN_SED_REPLACE) < $< > $@

doc/pcap-savefile.3: pcap-savefile.manfile.in
	sed $(MAN_SED_REPLACE) < $< > $@

#
# WinPcap/NPcap/Win10Pcap versioning hell :-(
#
# FILTER = sed -e 's/WINPCAP.* //'
# GREP   = grep --max-count=1 --only-matching
#
# ifeq ($(USE_WIN10PCAP),1)
#   WINPCAP_MAJOR = 10
#   WINPCAP_MINOR = 2
#   WINPCAP_REV   = 0
#   WINPCAP_BUILD = 5002
#
# else ifeq ($(USE_NPCAP),1)
#   #
#   # to-do: extract from $(NPCAP_ROOT)/version.h.
#   #
#   WINPCAP_MAJOR = 5
#   WINPCAP_MINOR = 0
#   WINPCAP_REV   = 9
#   WINPCAP_BUILD = 831
#
# else
#   WINPCAP_MAJOR := $(shell $(GREP) "WINPCAP_MAJOR .*" $(WINPCAP_ROOT)/version.h | $(FILTER))
#   WINPCAP_MINOR := $(shell $(GREP) "WINPCAP_MINOR .*" $(WINPCAP_ROOT)/version.h | $(FILTER))
#   WINPCAP_REV   := $(shell $(GREP) "WINPCAP_REV .*"   $(WINPCAP_ROOT)/version.h | $(FILTER))
#   WINPCAP_BUILD := $(shell $(GREP) "WINPCAP_BUILD .*" $(WINPCAP_ROOT)/version.h | $(FILTER))
# endif
#
# WINPCAP_RC_VERSION = $(WINPCAP_MAJOR),$(WINPCAP_MINOR),$(WINPCAP_REV),$(WINPCAP_BUILD)

#
# Export .def-file for wpcap2$(X64_SUFFIX).dll.
# If 'USE_NPCAP=1', then some extra functions are also exported.
# See below where this macro is used.
#
# For completeness, the 'pcap_*' functions in 'missing/win_*printf.c'
# are also exported.
#
define WPCAP2_DEF
  LIBRARY wpcap2$(X64_SUFFIX).dll
  EXPORTS
    PacketLibraryVersion
    PacketGetVersion
    PacketGetDriverVersion
    PacketOpenAdapter
    PacketSendPacket
    PacketSendPackets
    PacketAllocatePacket
    PacketFindAdInfo
    PacketInitPacket
    PacketFreePacket
    PacketReceivePacket
    PacketCloseAdapter
    PacketSetHwFilter
    PacketGetAdapterNames
    PacketRequest
    PacketSetBuff
    PacketSetBpf
    PacketSetSnapLen
    PacketGetStats
    PacketGetStatsEx
    PacketGetNetType
    PacketSetReadTimeout
    PacketSetMode
    PacketSetNumWrites
    PacketGetNetInfoEx
    PacketSetMinToCopy
    PacketGetReadEvent
    PacketStopDriver
    PacketSetDumpName
    PacketSetDumpLimits
    PacketIsDumpEnded
    PacketSetLoopbackBehavior
    PacketGetAirPcapHandle

  ; pcap_asprintf
  ; pcap_vasprintf
endef


#
# For cpp_filter.py used in .c -> .i rule.
#
define CPP_FILTER_PY
  import sys, os

  try:
    import ntpath
  except ImportError as e:
    print ("Failed to import ntpath: %s" % e)
    sys.exit(1)

  def _win32_abspath (path):
    path = ntpath.abspath (path)
    return path.replace ('\\', '/')

  def skip_cwd (s1, s2):
    ''' Skip the leading part that is in common with s1 and s2
    '''
    i = 0
    while i < len(s1) and s1[i] == s2[i]:
       i += 1
    return s2[i:]

  cwd = _win32_abspath (os.getcwd()) + '/'

  last_line  = '??'
  last_fname = '??'
  empty_lines = 0

  while True:
    line = sys.stdin.readline()
    if not line:
      break
    if line.startswith('\n') or line.startswith('\r'):
      empty_lines += 1
      continue

    if line.lstrip().startswith("#line"):
      line = line.replace ('\\\\', '/')
    fname = None
    quote = line.find ('\"')

    if line.startswith ("#line ") and quote > 0:
      fname = _win32_abspath (line[quote:])
      last_fname = fname

    if line.strip() != '' and last_line != '':
      if fname is None or fname != last_fname:
        print (line, end="")

    if line.strip() == '}' or line.strip() == '};':  # Print a newline after a functions or structs
      print ("")

    last_line = line

  if empty_lines > 0:
    sys.stderr.write ("Removed %d empty lines." % empty_lines)

endef

cpp_filter.py: $(THIS_FILE)
	@echo 'Generating $@...'
	$(file >  $@,#!/usr/env/python)
	$(file >> $@,#)
	$(file >> $@,# DO NOT EDIT! This file was generated automatically)
	$(file >> $@,# from $(realpath $(THIS_FILE)). Edit that file instead.)
	$(file >> $@,#)
	$(file >> $@,from __future__ import print_function)
	$(file >> $@,if 1:)
	$(file >> $@,$(CPP_FILTER_PY))

#### RPCAP Daemon rules ##########################################################

rpcapd_clean_0 \
rpcapd_vclean_0:
	$(call colour_msg,$(BRIGHT_GREEN)Nothing to do for $@ since 'HAVE_PCAP_REMOTE=0'.)

rpcapd_clean_1:
	rm -f rpcapd/rpcapd$(X64_SUFFIX).map

rpcapd_vclean_1:
	rm -f rpcapd/rpcapd$(X64_SUFFIX).exe rpcapd/rpcapd$(X64_SUFFIX).pdb

##################################################################################

clean:
	rm -f $(GENERATED) $(OBJ_DIR)/*.{$(O),rc,res,def}

vclean realclean: clean rpcapd_vclean_$(HAVE_PCAP_REMOTE)
	- rm -f $(TARGETS) $(TEST_PROGRAMS) $(FUZZ_PROGRAMS) $(LINK_CRAP) $(MAN3_PAGES) \
	        .depend.Windows link.tmp cpp_filter.py
	- rmdir $(OBJ_DIR)

#### Dependency generation #######################################################

DEP_REPLACE = sed -e 's@\(.*\)\.o: @\n$$(OBJ_DIR)\/\1.$$(O): @' \
                  -e 's@$(USBPCAP_ROOT)@$$(USBPCAP_ROOT)@'      \
                  -e 's@$(OPENSSL_ROOT)@$$(OPENSSL_ROOT)@'

DEP_CFLAGS = -MM $(filter -I% -D%, $(CFLAGS)) -DGCC_MAKE_DEPEND

#
# Fixed dependencies:
#
pcap-npf.c:               Win32/win32-misc.c
Win32/config.h:           pcap-trace.h
$(OBJ_DIR)/pcap-npf.$(O): pcap-npf.c Win32/win32-misc.c

$(WPCAP_OBJ)  \
$(RPCAPD_OBJ) \
$(PLUGIN_OBJ) \
$(OBJ_DIR)/pcap-plugin.$(O): WinPcap-plugins/pcap-plugin.h pcap-int.h # Win32/config.h
$(PLUGIN_OBJ):               WinPcap-plugins/pcap-plugin-interface.h

depend: $(GENERATED)
	$(call green_msg, Generating .depend.Windows...)
	@echo -en '#\n# Generated dependencies for MinGW, MSVC and clang-cl.\n# Generated at $(TODAY).\n#\n' > .depend.Windows
	gcc $(DEP_CFLAGS) $(ALL_SOURCES) | $(DEP_REPLACE) >> .depend.Windows

-include .depend.Windows
