#
# GNU Makefile for DOS-libpcap. djgpp 2.04+ version.
#
# Use this makefile from the libpcap root directory.
# E.g. like this:
#
#   c:\net\pcap> make -f msdos/Makefile.dj
#
# Note 1:
#   under plain DOS, you should do a "set LFN=y" first.
#
# Note 2:
#  If using this makefile under Windows (ref. 'DJ_PREFIX' below),
#  remember to do a 'make -f msdos/Makefile.dj clean' first in case
#  there are any leftovers from a Win32 build. E.g. a 'pcap_version.h'
#  generated for Windows does NOT work like 'msdos/pcap_version.h'.
#
MAKEFILE = msdos/Makefile.dj

VPATH = missing msdos bpf/net testsprogs

WATT32_ROOT = $(realpath $(WATT_ROOT))

OBJ_DIR = djgpp.obj

#
# Set "HAVE_PCAP_REMOTE=1" to enable remote packet-capture
# (nearly impossible on DOS).
#
HAVE_PCAP_REMOTE ?= 0

#
# Defines 'BDEBUG' and 'YYDEBUG'.
# See below.
#
PCAP_DEBUG ?= 0

#
# Set to 1 to create a detailed map-file.
#
MAKE_MAPFILE = 1

ifeq ($(OS),Windows_NT)
  #
  # Windows hosted djgpp cross compiler. Get it from:
  #   https://github.com/andrewwutw/build-djgpp/releases
  #
  # And set 'DJ_PREFIX' according to the 'c:/djgpp_cross_install_root'.
  #
  DJ_PREFIX ?= c:/djgpp_cross_install_root/bin/i586-pc-msdosdjgpp-
  CC = $(DJ_PREFIX)gcc
  IS_WINDOWS_HOSTED = 1

  #
  # A MinGW or a CygWin 'gcc'.
  #
  HOST_CC = gcc

else
  IS_WINDOWS_HOSTED = 0
  #
  # The normal djgpp 'gcc' for MSDOS.
  #
  CC      = gcc
  HOST_CC = $(CC)
endif

ASM  = nasm -fbin -dDEBUG
YACC = bison -p pcap_
FLEX = flex -P pcap_

CFLAGS = -g -O2 -Wall -I./msdos -I. -I$(WATT32_ROOT)/inc \
         -DHAVE_CONFIG_H -D_U_='__attribute__((unused))' \
         -Wno-unused-variable

ifneq ($(PCAP_DEBUG),0)
  CFLAGS += -DBDEBUG -DYYDEBUG=1
endif

PCAP_LIB = msdos/libpcap.a

GENERATED = msdos/config.h       \
            msdos/pcap_version.h \
            msdos/pkt_stub.inc   \
            scanner.c            \
            scanner.h            \
            grammar.c            \
            grammar.h

SOURCES = bpf/net/bpf_filter.c \
          bpf_image.c          \
          bpf_dump.c           \
          etherent.c           \
          fmtutils.c           \
          gencode.c            \
          grammar.c            \
          nametoaddr.c         \
          optimize.c           \
          pcap.c               \
          pcap-common.c        \
          pcap-dos.c           \
          savefile.c           \
          sf-pcap.c            \
          sf-pcap-ng.c         \
          scanner.c            \
          msdos/pktdrvr.c

ifeq ($(HAVE_PCAP_REMOTE),1)
  CFLAGS  += -DHAVE_REMOTE
  SOURCES += pcap-new.c pcap-rpcap.c sockutils.c
endif

LIB_OBJ  = $(addprefix $(OBJ_DIR)/, $(notdir $(SOURCES:.c=.o)))
TEMP_BIN = tmp.bin

TARGETS = $(PCAP_LIB)            \
          can_set_rfmon_test.exe \
          capturetest.exe        \
          filtertest.exe         \
          findalldevstest.exe    \
          opentest.exe

#
# From the make manual, sec. 10.4:
#   You can prevent automatic deletion of an intermediate file by marking it as a secondary
#   file. To do this, list it as a prerequisite of the special target .SECONDARY. When a file
#   is secondary, make will not create the file merely because it does not already exist, but
#   make does not automatically delete the file.
#
TEST_OBJ = $(addprefix $(OBJ_DIR)/, \
             can_set_rfmon_test.o   \
             capturetest.o          \
             filtertest.o           \
             findalldevstest.o      \
             opentest.o)

.SECONDARY: $(TEST_OBJ)

all: $(GENERATED) $(TARGETS)
	@echo 'Welcome to libpcap/djgpp with samples.'

$(LIB_OBJ): $(OBJ_DIR)

$(OBJ_DIR):
	-mkdir $@

$(PCAP_LIB): msdos/config.h msdos/pcap_version.h $(LIB_OBJ)
	rm -f $@
	ar rs $@ $^

$(OBJ_DIR)/%.o: %.c
	$(CC) -c $(CFLAGS) -o $@ $<
	@echo

$(OBJ_DIR)/%.o: %.s
	$(CC) -c $(CFLAGS) -x assembler-with-cpp -o $@ $<
	@echo

%.exe: $(OBJ_DIR)/%.o $(PCAP_LIB)
	$(call link_EXE, $@, $^ $(WATT32_ROOT)/lib/libwatt.a, $(@:.exe=.map))

msdos/pkt_stub.inc: msdos/bin2c.exe msdos/pkt_rx1.S
	$(ASM) -o $(TEMP_BIN) -lmsdos/pkt_rx1.lst msdos/pkt_rx1.S
	./msdos/bin2c $(TEMP_BIN) > $@
	rm -f $(TEMP_BIN)

grammar.h: grammar.c

grammar.c: grammar.y
	$(YACC) --yacc --defines grammar.y
	@mv -f y.tab.c grammar.c
	@mv -f y.tab.h grammar.h
	@echo

scanner.c scanner.h: scanner.l
	$(FLEX) --header-file=scanner.h --outfile=scanner.c $<
	@echo

msdos/config.h: $(MAKEFILE)
	$(call Generate_file, $@)
	$(file >> $@,$(CONFIG_H))

msdos/pcap_version.h: $(MAKEFILE) # ./VERSION
	$(call Generate_file, $@)
	$(file >> $@,$(PCAP_VERSION_H))

msdos/bin2c.exe: msdos/bin2c.c
	$(HOST_CC) $< -o $@

clean:
	rm -f $(LIB_OBJ) $(TEST_OBJ) $(GENERATED) msdos/pkt_rx1.lst msdos/bin2c.exe msdos/.depend.dj

vclean: clean
	rm -f $(TARGETS) $(TARGETS:.exe=.map)
	-rmdir $(OBJ_DIR)

define CONFIG_H
  #define DEBUG          1
  #define HAVE_FFS       1
  #define HAVE_LIMITS_H  1
  #define HAVE_STRERROR  1
  #define HAVE_STRLCAT   1
  #define HAVE_STRLCPY   1
  #define HAVE_SNPRINTF  1
  #define HAVE_VSNPRINTF 1
  #define in_addr_t      u_long /* Only needed in tests/filtertest.c */
//#define yylval         pcap_lval

//#define PCAP_TRACE(level, fmt, ...)  (void)0
  #define PACKAGE_VERSION              "libpcap version $(shell cat ./VERSION)"

endef

define PCAP_VERSION_H
  #if !defined(MSDOS)
    #error This file is for MSDOS only
  #endif

  /*
   *  If building under Windows, there is a good chance there is aleady
   * "pcap_version.h" in the libpcap root. Hence this generated file
   *  is in the 'msdos' subdirectory.
   */
  #undef  PCAP_VERSION_STRING
  #define PCAP_VERSION_STRING  "libpcap/djgpp ($(shell cat ./VERSION))"
endef

#
# Create a file with header.
#  $(1): file to write to.
#
define Generate_file
  $(info2 Generating $(1) ...)
  $(file  > $(1), /*)
  $(file >> $(1),  * Generated $(strip $(1)) for djgpp.)
  $(file >> $(1),  * DO NOT EDIT. Edit $(realpath $(MAKEFILE)) instead.)
  $(file >> $(1),  */)
endef

ifeq ($(MAKE_MAPFILE),0)
  define link_EXE
    $(CC) -o $(1) $(2)
    @echo
  endef

else ifeq ($(IS_WINDOWS_HOSTED),1)
  #
  # A Windows-hosted 'gcc' will print .map-file info to 'stdout'.
  # Hence this special handling.
  #
  define link_EXE
    $(CC) -Wl,--print-map -o $(1) $(2) > $(3)
    @echo
  endef

else
  #
  # I assume under plain DOS, one has to use the 'redir' command
  # since 'stderr' is used to output a .map-file. That used to
  # be the case in the old days. But untested by me.
  #
  define link_EXE
    redir -e $(3) $(CC) -Wl,--print-map -o $(1) $(2)
    @echo
  endef
endif

#
# Manually generated dependencies
#
msdos/pktdrvr.c: msdos/pkt_stub.inc
scanner.c: scanner.l
grammar.c: grammar.y
grammar.h: grammar.y
scanner.l: pcap-int.h pcap-namedb.h gencode.h grammar.h
grammar.y: pcap-int.h gencode.h pcap-namedb.h

#
# Generate dependencies.
#
REPLACE = sed -e 's@\(.*\)\.o: @\n$$(OBJ_DIR)\/\1.o: @g' \
              -e 's@$(WATT32_ROOT)@$$(WATT32_ROOT)@g'

depend: $(GENERATED)
	$(CC) -MM $(CFLAGS) $(SOURCES) | $(REPLACE) > msdos/.depend.dj

-include msdos/.depend.dj

